!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	//
$(BUILD_DIR)/assert.o	makefile	/^$(BUILD_DIR)\/assert.o: lib\/user\/assert.c lib\/user\/assert.h lib\/stdio.h lib\/stdint.h$/;"	t
$(BUILD_DIR)/bitmap.o	makefile	/^$(BUILD_DIR)\/bitmap.o: lib\/kernel\/bitmap.c lib\/kernel\/bitmap.h \\$/;"	t
$(BUILD_DIR)/buildin_cmd.o	makefile	/^$(BUILD_DIR)\/buildin_cmd.o: shell\/buildin_cmd.c shell\/buildin_cmd.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/console.o	makefile	/^$(BUILD_DIR)\/console.o: device\/console.c device\/console.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/debug.o	makefile	/^$(BUILD_DIR)\/debug.o: kernel\/debug.c kernel\/debug.h \\$/;"	t
$(BUILD_DIR)/dir.o	makefile	/^$(BUILD_DIR)\/dir.o: fs\/dir.c fs\/dir.h lib\/stdint.h fs\/inode.h lib\/kernel\/list.h \\$/;"	t
$(BUILD_DIR)/exec.o	makefile	/^$(BUILD_DIR)\/exec.o: userprog\/exec.c userprog\/exec.h thread\/thread.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/file.o	makefile	/^$(BUILD_DIR)\/file.o: fs\/file.c fs\/file.h lib\/stdint.h device\/ide.h thread\/sync.h \\$/;"	t
$(BUILD_DIR)/fork.o	makefile	/^$(BUILD_DIR)\/fork.o: userprog\/fork.c userprog\/fork.h thread\/thread.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/fs.o	makefile	/^$(BUILD_DIR)\/fs.o: fs\/fs.c fs\/fs.h lib\/stdint.h device\/ide.h thread\/sync.h lib\/kernel\/li/;"	t
$(BUILD_DIR)/ide.o	makefile	/^$(BUILD_DIR)\/ide.o: device\/ide.c device\/ide.h lib\/stdint.h thread\/sync.h \\$/;"	t
$(BUILD_DIR)/init.o	makefile	/^$(BUILD_DIR)\/init.o: kernel\/init.c kernel\/init.h lib\/kernel\/print.h \\$/;"	t
$(BUILD_DIR)/inode.o	makefile	/^$(BUILD_DIR)\/inode.o: fs\/inode.c fs\/inode.h lib\/stdint.h lib\/kernel\/list.h \\$/;"	t
$(BUILD_DIR)/interrupt.o	makefile	/^$(BUILD_DIR)\/interrupt.o: kernel\/interrupt.c kernel\/interrupt.h \\$/;"	t
$(BUILD_DIR)/ioqueue.o	makefile	/^$(BUILD_DIR)\/ioqueue.o: device\/ioqueue.c device\/ioqueue.h lib\/stdint.h thread\/thread.h \\$/;"	t
$(BUILD_DIR)/kernel.bin	makefile	/^$(BUILD_DIR)\/kernel.bin: $(OBJS)$/;"	t
$(BUILD_DIR)/kernel.o	makefile	/^$(BUILD_DIR)\/kernel.o: kernel\/kernel.S$/;"	t
$(BUILD_DIR)/keyboard.o	makefile	/^$(BUILD_DIR)\/keyboard.o: device\/keyboard.c device\/keyboard.h lib\/kernel\/print.h \\$/;"	t
$(BUILD_DIR)/list.o	makefile	/^$(BUILD_DIR)\/list.o: lib\/kernel\/list.c lib\/kernel\/list.h kernel\/global.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/loader.bin	makefile	/^$(BUILD_DIR)\/loader.bin: boot\/loader.S $/;"	t
$(BUILD_DIR)/main.o	makefile	/^$(BUILD_DIR)\/main.o: kernel\/main.c lib\/kernel\/print.h \\$/;"	t
$(BUILD_DIR)/mbr.bin	makefile	/^$(BUILD_DIR)\/mbr.bin: boot\/mbr.S $/;"	t
$(BUILD_DIR)/memory.o	makefile	/^$(BUILD_DIR)\/memory.o: kernel\/memory.c kernel\/memory.h lib\/stdint.h lib\/kernel\/bitmap.h \\$/;"	t
$(BUILD_DIR)/pipe.o	makefile	/^$(BUILD_DIR)\/pipe.o: shell\/pipe.c shell\/pipe.h lib\/stdint.h kernel\/memory.h \\$/;"	t
$(BUILD_DIR)/print.o	makefile	/^$(BUILD_DIR)\/print.o: lib\/kernel\/print.S$/;"	t
$(BUILD_DIR)/process.o	makefile	/^$(BUILD_DIR)\/process.o: userprog\/process.c userprog\/process.h thread\/thread.h \\$/;"	t
$(BUILD_DIR)/shell.o	makefile	/^$(BUILD_DIR)\/shell.o: shell\/shell.c shell\/shell.h lib\/stdint.h fs\/fs.h \\$/;"	t
$(BUILD_DIR)/stdio-kernel.o	makefile	/^$(BUILD_DIR)\/stdio-kernel.o: lib\/kernel\/stdio-kernel.c lib\/kernel\/stdio-kernel.h lib\/stdin/;"	t
$(BUILD_DIR)/stdio.o	makefile	/^$(BUILD_DIR)\/stdio.o: lib\/stdio.c lib\/stdio.h lib\/stdint.h kernel\/interrupt.h \\$/;"	t
$(BUILD_DIR)/string.o	makefile	/^$(BUILD_DIR)\/string.o: lib\/string.c lib\/string.h \\$/;"	t
$(BUILD_DIR)/switch.o	makefile	/^$(BUILD_DIR)\/switch.o: thread\/switch.S$/;"	t
$(BUILD_DIR)/sync.o	makefile	/^$(BUILD_DIR)\/sync.o: thread\/sync.c thread\/sync.h lib\/kernel\/list.h kernel\/global.h \\$/;"	t
$(BUILD_DIR)/syscall-init.o	makefile	/^$(BUILD_DIR)\/syscall-init.o: userprog\/syscall-init.c userprog\/syscall-init.h \\$/;"	t
$(BUILD_DIR)/syscall.o	makefile	/^$(BUILD_DIR)\/syscall.o: lib\/user\/syscall.c lib\/user\/syscall.h lib\/stdint.h$/;"	t
$(BUILD_DIR)/thread.o	makefile	/^$(BUILD_DIR)\/thread.o: thread\/thread.c thread\/thread.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/timer.o	makefile	/^$(BUILD_DIR)\/timer.o: device\/timer.c device\/timer.h lib\/stdint.h\\$/;"	t
$(BUILD_DIR)/tss.o	makefile	/^$(BUILD_DIR)\/tss.o: userprog\/tss.c userprog\/tss.h thread\/thread.h lib\/stdint.h \\$/;"	t
$(BUILD_DIR)/wait_exit.o	makefile	/^$(BUILD_DIR)\/wait_exit.o: userprog\/wait_exit.c userprog\/wait_exit.h \\$/;"	t
AS	makefile	/^AS = nasm$/;"	m
ASBINLIB	makefile	/^ASBINLIB = -I boot\/include\/$/;"	m
ASFLAGS	makefile	/^ASFLAGS = -f elf $/;"	m
ASSERT	kernel/debug.h	/^   #define ASSERT(/;"	d
BITMAP_MASK	lib/kernel/bitmap.h	/^#define BITMAP_MASK /;"	d
BITS_PER_SECTOR	fs/fs.h	/^#define BITS_PER_SECTOR /;"	d
BIT_DEV_DEV	device/ide.c	/^#define BIT_DEV_DEV	/;"	d	file:
BIT_DEV_LBA	device/ide.c	/^#define BIT_DEV_LBA	/;"	d	file:
BIT_DEV_MBS	device/ide.c	/^#define BIT_DEV_MBS	/;"	d	file:
BIT_STAT_BSY	device/ide.c	/^#define BIT_STAT_BSY	/;"	d	file:
BIT_STAT_DRDY	device/ide.c	/^#define BIT_STAT_DRDY	/;"	d	file:
BIT_STAT_DRQ	device/ide.c	/^#define BIT_STAT_DRQ	/;"	d	file:
BLOCK_BITMAP	fs/file.h	/^   BLOCK_BITMAP	     \/\/ 块位图$/;"	e	enum:bitmap_type
BLOCK_SIZE	fs/fs.h	/^#define BLOCK_SIZE /;"	d
BUILD_DIR	makefile	/^BUILD_DIR = .\/build$/;"	m
CC	makefile	/^CC = gcc$/;"	m
CFLAGS	makefile	/^CFLAGS = -m32 -Wall $(LIB) -c -fno-builtin -W -Wstrict-prototypes \\$/;"	m
CMD_IDENTIFY	device/ide.c	/^#define CMD_IDENTIFY	/;"	d	file:
CMD_READ_SECTOR	device/ide.c	/^#define CMD_READ_SECTOR	/;"	d	file:
CMD_WRITE_SECTOR	device/ide.c	/^#define CMD_WRITE_SECTOR /;"	d	file:
CODE_DESC	boot/loader.S	/^   CODE_DESC:  dd    0x0000FFFF $/;"	d
CONTRER0_PORT	device/timer.c	/^#define CONTRER0_PORT	/;"	d	file:
COUNTER0_NO	device/timer.c	/^#define COUNTER0_NO	/;"	d	file:
COUNTER0_VALUE	device/timer.c	/^#define COUNTER0_VALUE	/;"	d	file:
COUNTER_MODE	device/timer.c	/^#define COUNTER_MODE	/;"	d	file:
DATA_STACK_DESC	boot/loader.S	/^   DATA_STACK_DESC:  dd    0x0000FFFF$/;"	d
DEFAULT_SECS	fs/file.c	/^#define DEFAULT_SECS /;"	d	file:
DESC_AVL	kernel/global.h	/^#define DESC_AVL /;"	d
DESC_CNT	kernel/memory.h	/^#define DESC_CNT /;"	d
DESC_DPL_0	kernel/global.h	/^#define DESC_DPL_0 /;"	d
DESC_DPL_1	kernel/global.h	/^#define DESC_DPL_1 /;"	d
DESC_DPL_2	kernel/global.h	/^#define DESC_DPL_2 /;"	d
DESC_DPL_3	kernel/global.h	/^#define DESC_DPL_3 /;"	d
DESC_D_32	kernel/global.h	/^#define	DESC_D_32 /;"	d
DESC_G_4K	kernel/global.h	/^#define	DESC_G_4K /;"	d
DESC_L	kernel/global.h	/^#define DESC_L	/;"	d
DESC_P	kernel/global.h	/^#define DESC_P	/;"	d
DESC_S_CODE	kernel/global.h	/^#define DESC_S_CODE	/;"	d
DESC_S_DATA	kernel/global.h	/^#define DESC_S_DATA	/;"	d
DESC_S_SYS	kernel/global.h	/^#define DESC_S_SYS	/;"	d
DESC_TYPE_CODE	kernel/global.h	/^#define DESC_TYPE_CODE	/;"	d
DESC_TYPE_DATA	kernel/global.h	/^#define DESC_TYPE_DATA /;"	d
DESC_TYPE_TSS	kernel/global.h	/^#define DESC_TYPE_TSS /;"	d
DISK_IMG	makefile	/^DISK_IMG = hd3M.img$/;"	m
DISK_IMG2	makefile	/^DISK_IMG2 = hd50M.img$/;"	m
DIV_ROUND_UP	kernel/global.h	/^#define DIV_ROUND_UP(/;"	d
EFLAGS_IF	kernel/interrupt.c	/^#define EFLAGS_IF /;"	d	file:
EFLAGS_IF_0	kernel/global.h	/^#define EFLAGS_IF_0	/;"	d
EFLAGS_IF_1	kernel/global.h	/^#define EFLAGS_IF_1	/;"	d
EFLAGS_IOPL_0	kernel/global.h	/^#define EFLAGS_IOPL_0	/;"	d
EFLAGS_IOPL_3	kernel/global.h	/^#define EFLAGS_IOPL_3	/;"	d
EFLAGS_MBS	kernel/global.h	/^#define EFLAGS_MBS	/;"	d
ENTRY_POINT	makefile	/^ENTRY_POINT = 0xc0001500$/;"	m
Elf32_Addr	userprog/exec.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	typeref:typename:uint32_t	file:
Elf32_Ehdr	userprog/exec.c	/^struct Elf32_Ehdr {$/;"	s	file:
Elf32_Half	userprog/exec.c	/^typedef uint16_t Elf32_Half;$/;"	t	typeref:typename:uint16_t	file:
Elf32_Off	userprog/exec.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	typeref:typename:uint32_t	file:
Elf32_Phdr	userprog/exec.c	/^struct Elf32_Phdr {$/;"	s	file:
Elf32_Word	userprog/exec.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	typeref:typename:uint32_t	file:
FT_DIRECTORY	fs/fs.h	/^   FT_DIRECTORY	  \/\/ 目录$/;"	e	enum:file_types
FT_REGULAR	fs/fs.h	/^   FT_REGULAR,	  \/\/ 普通文件$/;"	e	enum:file_types
FT_UNKNOWN	fs/fs.h	/^   FT_UNKNOWN,	  \/\/ 不支持的文件类型$/;"	e	enum:file_types
GDT_ATTR_HIGH	kernel/global.h	/^#define GDT_ATTR_HIGH	/;"	d
GDT_BASE	boot/loader.S	/^   GDT_BASE:   dd    0x00000000 $/;"	d
GDT_CODE_ATTR_LOW_DPL3	kernel/global.h	/^#define GDT_CODE_ATTR_LOW_DPL3	/;"	d
GDT_DATA_ATTR_LOW_DPL3	kernel/global.h	/^#define GDT_DATA_ATTR_LOW_DPL3	/;"	d
GDT_LIMIT	boot/loader.S	/^   GDT_LIMIT   equ   GDT_SIZE -	1 $/;"	d
GDT_SIZE	boot/loader.S	/^   GDT_SIZE   equ   $ - GDT_BASE$/;"	d
GET_EFLAGS	kernel/interrupt.c	/^#define GET_EFLAGS(/;"	d	file:
IDT_DESC_16_TYPE	kernel/global.h	/^#define	 IDT_DESC_16_TYPE /;"	d
IDT_DESC_32_TYPE	kernel/global.h	/^#define	 IDT_DESC_32_TYPE /;"	d
IDT_DESC_ATTR_DPL0	kernel/global.h	/^#define	 IDT_DESC_ATTR_DPL0 /;"	d
IDT_DESC_ATTR_DPL3	kernel/global.h	/^#define	 IDT_DESC_ATTR_DPL3 /;"	d
IDT_DESC_CNT	kernel/interrupt.c	/^#define IDT_DESC_CNT /;"	d	file:
IDT_DESC_DPL0	kernel/global.h	/^#define	 IDT_DESC_DPL0 /;"	d
IDT_DESC_DPL3	kernel/global.h	/^#define	 IDT_DESC_DPL3 /;"	d
IDT_DESC_P	kernel/global.h	/^#define	 IDT_DESC_P	/;"	d
INODE_BITMAP	fs/file.h	/^   INODE_BITMAP,     \/\/ inode位图$/;"	e	enum:bitmap_type
INPUT_FREQUENCY	device/timer.c	/^#define INPUT_FREQUENCY	/;"	d	file:
INTR_OFF	kernel/interrupt.h	/^    INTR_OFF,			 \/\/ 中断关闭$/;"	e	enum:intr_status
INTR_ON	kernel/interrupt.h	/^    INTR_ON		         \/\/ 中断打开$/;"	e	enum:intr_status
IRQ0_FREQUENCY	device/timer.c	/^#define IRQ0_FREQUENCY	/;"	d	file:
KBD_BUF_PORT	device/keyboard.c	/^#define KBD_BUF_PORT /;"	d	file:
K_HEAP_START	kernel/memory.c	/^#define K_HEAP_START /;"	d	file:
LD	makefile	/^LD = ld$/;"	m
LDFLAGS	makefile	/^LDFLAGS = -melf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)\/kernel.map$/;"	m
LIB	makefile	/^LIB = -I lib\/ -I lib\/kernel\/ -I lib\/user\/ -I kernel\/ -I device\/ -I thread\/  -I userprog\//;"	m
MAX_ARG_NR	shell/shell.c	/^#define MAX_ARG_NR /;"	d	file:
MAX_FILES_OPEN_PER_PROC	thread/thread.h	/^#define MAX_FILES_OPEN_PER_PROC /;"	d
MAX_FILES_PER_PART	fs/fs.h	/^#define MAX_FILES_PER_PART /;"	d
MAX_FILE_NAME_LEN	fs/dir.h	/^#define MAX_FILE_NAME_LEN /;"	d
MAX_FILE_OPEN	fs/file.h	/^#define MAX_FILE_OPEN /;"	d
MAX_PATH_LEN	fs/fs.h	/^#define MAX_PATH_LEN /;"	d
MEM_BITMAP_BASE	kernel/memory.c	/^#define MEM_BITMAP_BASE /;"	d	file:
NULL	kernel/global.h	/^#define NULL /;"	d
NULL	lib/user/assert.h	/^#define NULL /;"	d
OBJS	makefile	/^OBJS = $(BUILD_DIR)\/main.o $(BUILD_DIR)\/init.o $(BUILD_DIR)\/interrupt.o \\$/;"	m
O_CREAT	fs/fs.h	/^   O_CREAT = 4	  \/\/ 创建$/;"	e	enum:oflags
O_RDONLY	fs/fs.h	/^   O_RDONLY,	  \/\/ 只读$/;"	e	enum:oflags
O_RDWR	fs/fs.h	/^   O_RDWR,	  \/\/ 读写$/;"	e	enum:oflags
O_WRONLY	fs/fs.h	/^   O_WRONLY,	  \/\/ 只写$/;"	e	enum:oflags
PANIC	kernel/debug.h	/^#define PANIC(/;"	d
PDE_IDX	kernel/memory.c	/^#define PDE_IDX(/;"	d	file:
PF_KERNEL	kernel/memory.h	/^   PF_KERNEL = 1,    \/\/ 内核内存池$/;"	e	enum:pool_flags
PF_USER	kernel/memory.h	/^   PF_USER = 2	     \/\/ 用户内存池$/;"	e	enum:pool_flags
PG_P_0	kernel/memory.h	/^#define	 PG_P_0	/;"	d
PG_P_1	kernel/memory.h	/^#define	 PG_P_1	/;"	d
PG_RW_R	kernel/memory.h	/^#define	 PG_RW_R /;"	d
PG_RW_W	kernel/memory.h	/^#define	 PG_RW_W /;"	d
PG_SIZE	kernel/global.h	/^#define PG_SIZE /;"	d
PG_US_S	kernel/memory.h	/^#define	 PG_US_S /;"	d
PG_US_U	kernel/memory.h	/^#define	 PG_US_U /;"	d
PIC_M_CTRL	kernel/interrupt.c	/^#define PIC_M_CTRL /;"	d	file:
PIC_M_DATA	kernel/interrupt.c	/^#define PIC_M_DATA /;"	d	file:
PIC_S_CTRL	kernel/interrupt.c	/^#define PIC_S_CTRL /;"	d	file:
PIC_S_DATA	kernel/interrupt.c	/^#define PIC_S_DATA /;"	d	file:
PIPE_FLAG	shell/pipe.h	/^#define PIPE_FLAG /;"	d
PIT_CONTROL_PORT	device/timer.c	/^#define PIT_CONTROL_PORT /;"	d	file:
PTE_IDX	kernel/memory.c	/^#define PTE_IDX(/;"	d	file:
PTNULL	boot/loader.S	/^.PTNULL:$/;"	l
PT_DYNAMIC	userprog/exec.c	/^   PT_DYNAMIC,         \/\/ 动态加载信息 $/;"	e	enum:segment_type	file:
PT_INTERP	userprog/exec.c	/^   PT_INTERP,          \/\/ 动态加载器名称$/;"	e	enum:segment_type	file:
PT_LOAD	userprog/exec.c	/^   PT_LOAD,            \/\/ 可加载程序段$/;"	e	enum:segment_type	file:
PT_NOTE	userprog/exec.c	/^   PT_NOTE,            \/\/ 一些辅助信息$/;"	e	enum:segment_type	file:
PT_NULL	userprog/exec.c	/^   PT_NULL,            \/\/ 忽略$/;"	e	enum:segment_type	file:
PT_PHDR	userprog/exec.c	/^   PT_PHDR             \/\/ 程序头表$/;"	e	enum:segment_type	file:
PT_SHLIB	userprog/exec.c	/^   PT_SHLIB,           \/\/ 保留$/;"	e	enum:segment_type	file:
READ_WRITE_LATCH	device/timer.c	/^#define READ_WRITE_LATCH /;"	d	file:
RPL0	kernel/global.h	/^#define	 RPL0 /;"	d
RPL0	lib/kernel/print.S	/^RPL0  equ   0$/;"	d
RPL1	kernel/global.h	/^#define	 RPL1 /;"	d
RPL2	kernel/global.h	/^#define	 RPL2 /;"	d
RPL3	kernel/global.h	/^#define	 RPL3 /;"	d
SECTOR_SIZE	fs/fs.h	/^#define SECTOR_SIZE /;"	d
SEEK_CUR	fs/fs.h	/^   SEEK_CUR,$/;"	e	enum:whence
SEEK_END	fs/fs.h	/^   SEEK_END$/;"	e	enum:whence
SEEK_SET	fs/fs.h	/^   SEEK_SET = 1,$/;"	e	enum:whence
SELECTOR_CODE	boot/loader.S	/^   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)\/8 + /;"	d
SELECTOR_DATA	boot/loader.S	/^   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	 ; 同上$/;"	d
SELECTOR_K_CODE	kernel/global.h	/^#define SELECTOR_K_CODE	/;"	d
SELECTOR_K_DATA	kernel/global.h	/^#define SELECTOR_K_DATA	/;"	d
SELECTOR_K_GS	kernel/global.h	/^#define SELECTOR_K_GS	/;"	d
SELECTOR_K_STACK	kernel/global.h	/^#define SELECTOR_K_STACK /;"	d
SELECTOR_TSS	kernel/global.h	/^#define SELECTOR_TSS /;"	d
SELECTOR_U_CODE	kernel/global.h	/^#define SELECTOR_U_CODE	/;"	d
SELECTOR_U_DATA	kernel/global.h	/^#define SELECTOR_U_DATA	/;"	d
SELECTOR_U_STACK	kernel/global.h	/^#define SELECTOR_U_STACK /;"	d
SELECTOR_VIDEO	boot/loader.S	/^   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	 ; 同上 $/;"	d
SELECTOR_VIDEO	lib/kernel/print.S	/^SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0$/;"	d
SYSCALL_NR	lib/user/syscall.h	/^enum SYSCALL_NR {$/;"	g
SYS_CHDIR	lib/user/syscall.h	/^   SYS_CHDIR,$/;"	e	enum:SYSCALL_NR
SYS_CLEAR	lib/user/syscall.h	/^   SYS_CLEAR,$/;"	e	enum:SYSCALL_NR
SYS_CLOSE	lib/user/syscall.h	/^   SYS_CLOSE,$/;"	e	enum:SYSCALL_NR
SYS_CLOSEDIR	lib/user/syscall.h	/^   SYS_CLOSEDIR,$/;"	e	enum:SYSCALL_NR
SYS_EXECV	lib/user/syscall.h	/^   SYS_EXECV,$/;"	e	enum:SYSCALL_NR
SYS_EXIT	lib/user/syscall.h	/^   SYS_EXIT,$/;"	e	enum:SYSCALL_NR
SYS_FD_REDIRECT	lib/user/syscall.h	/^   SYS_FD_REDIRECT,$/;"	e	enum:SYSCALL_NR
SYS_FORK	lib/user/syscall.h	/^   SYS_FORK,$/;"	e	enum:SYSCALL_NR
SYS_FREE	lib/user/syscall.h	/^   SYS_FREE,$/;"	e	enum:SYSCALL_NR
SYS_GETCWD	lib/user/syscall.h	/^   SYS_GETCWD,$/;"	e	enum:SYSCALL_NR
SYS_GETPID	lib/user/syscall.h	/^   SYS_GETPID,$/;"	e	enum:SYSCALL_NR
SYS_HELP	lib/user/syscall.h	/^   SYS_HELP$/;"	e	enum:SYSCALL_NR
SYS_LSEEK	lib/user/syscall.h	/^   SYS_LSEEK,$/;"	e	enum:SYSCALL_NR
SYS_MALLOC	lib/user/syscall.h	/^   SYS_MALLOC,$/;"	e	enum:SYSCALL_NR
SYS_MKDIR	lib/user/syscall.h	/^   SYS_MKDIR,$/;"	e	enum:SYSCALL_NR
SYS_OPEN	lib/user/syscall.h	/^   SYS_OPEN,$/;"	e	enum:SYSCALL_NR
SYS_OPENDIR	lib/user/syscall.h	/^   SYS_OPENDIR,$/;"	e	enum:SYSCALL_NR
SYS_PIPE	lib/user/syscall.h	/^   SYS_PIPE,$/;"	e	enum:SYSCALL_NR
SYS_PS	lib/user/syscall.h	/^   SYS_PS,$/;"	e	enum:SYSCALL_NR
SYS_PUTCHAR	lib/user/syscall.h	/^   SYS_PUTCHAR,$/;"	e	enum:SYSCALL_NR
SYS_READ	lib/user/syscall.h	/^   SYS_READ,$/;"	e	enum:SYSCALL_NR
SYS_READDIR	lib/user/syscall.h	/^   SYS_READDIR,$/;"	e	enum:SYSCALL_NR
SYS_REWINDDIR	lib/user/syscall.h	/^   SYS_REWINDDIR,$/;"	e	enum:SYSCALL_NR
SYS_RMDIR	lib/user/syscall.h	/^   SYS_RMDIR,$/;"	e	enum:SYSCALL_NR
SYS_STAT	lib/user/syscall.h	/^   SYS_STAT,$/;"	e	enum:SYSCALL_NR
SYS_UNLINK	lib/user/syscall.h	/^   SYS_UNLINK,$/;"	e	enum:SYSCALL_NR
SYS_WAIT	lib/user/syscall.h	/^   SYS_WAIT,$/;"	e	enum:SYSCALL_NR
SYS_WRITE	lib/user/syscall.h	/^   SYS_WRITE,$/;"	e	enum:SYSCALL_NR
TASK_BLOCKED	thread/thread.h	/^   TASK_BLOCKED,$/;"	e	enum:task_status
TASK_DIED	thread/thread.h	/^   TASK_DIED$/;"	e	enum:task_status
TASK_HANGING	thread/thread.h	/^   TASK_HANGING,$/;"	e	enum:task_status
TASK_NAME_LEN	thread/thread.h	/^#define TASK_NAME_LEN /;"	d
TASK_READY	thread/thread.h	/^   TASK_READY,$/;"	e	enum:task_status
TASK_RUNNING	thread/thread.h	/^   TASK_RUNNING,$/;"	e	enum:task_status
TASK_WAITING	thread/thread.h	/^   TASK_WAITING,$/;"	e	enum:task_status
TI_GDT	kernel/global.h	/^#define TI_GDT /;"	d
TI_GDT	lib/kernel/print.S	/^TI_GDT equ  0$/;"	d
TI_LDT	kernel/global.h	/^#define TI_LDT /;"	d
TSS_ATTR_HIGH	kernel/global.h	/^#define TSS_ATTR_HIGH /;"	d
TSS_ATTR_LOW	kernel/global.h	/^#define TSS_ATTR_LOW /;"	d
TSS_DESC_D	kernel/global.h	/^#define TSS_DESC_D /;"	d
UNUSED	kernel/global.h	/^#define UNUSED /;"	d
USER_STACK3_VADDR	userprog/process.h	/^#define USER_STACK3_VADDR /;"	d
USER_VADDR_START	userprog/process.h	/^#define USER_VADDR_START /;"	d
VECTOR	kernel/kernel.S	/^VECTOR 0x00,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x01,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x02,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x03,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x04,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x05,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x06,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x07,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x08,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x09,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0a,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0b,ERROR_CODE $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0c,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0d,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0e,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0f,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x10,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x11,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x12,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x13,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x14,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x15,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x16,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x17,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x18,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x19,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1a,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1b,ERROR_CODE $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1c,ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1d,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1e,ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1f,ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x20,ZERO	;时钟中断对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x21,ZERO	;键盘中断对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x22,ZERO	;级联用的$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x23,ZERO	;串口2对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x24,ZERO	;串口1对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x25,ZERO	;并口2对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x26,ZERO	;软盘对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x27,ZERO	;并口1对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x28,ZERO	;实时时钟对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x29,ZERO	;重定向$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2a,ZERO	;保留$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2b,ZERO	;保留$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2c,ZERO	;ps\/2鼠标$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2d,ZERO	;fpu浮点单元异常$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2e,ZERO	;硬盘$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2f,ZERO	;保留$/;"	l
VIDEO_DESC	boot/loader.S	/^   VIDEO_DESC: dd    0x80000007	       ; limit=(0xbffff-0xb8000)\/4k=0x7$/;"	d
__DEVICE_CONSOLE_H	device/console.h	/^#define __DEVICE_CONSOLE_H$/;"	d
__DEVICE_IDE_H	device/ide.h	/^#define __DEVICE_IDE_H$/;"	d
__DEVICE_IOQUEUE_H	device/ioqueue.h	/^#define __DEVICE_IOQUEUE_H$/;"	d
__DEVICE_KEYBOARD_H	device/keyboard.h	/^#define __DEVICE_KEYBOARD_H$/;"	d
__DEVICE_TIME_H	device/timer.h	/^#define __DEVICE_TIME_H$/;"	d
__FS_DIR_H	fs/dir.h	/^#define __FS_DIR_H$/;"	d
__FS_FILE_H	fs/file.h	/^#define __FS_FILE_H$/;"	d
__FS_FS_H	fs/fs.h	/^#define __FS_FS_H$/;"	d
__FS_INODE_H	fs/inode.h	/^#define __FS_INODE_H$/;"	d
__FS_SUPER_BLOCK_H	fs/super_block.h	/^#define __FS_SUPER_BLOCK_H$/;"	d
__KERNEL_DEBUG_H	kernel/debug.h	/^#define __KERNEL_DEBUG_H$/;"	d
__KERNEL_GLOBAL_H	kernel/global.h	/^#define __KERNEL_GLOBAL_H$/;"	d
__KERNEL_INIT_H	kernel/init.h	/^#define __KERNEL_INIT_H$/;"	d
__KERNEL_INTERRUPT_H	kernel/interrupt.h	/^#define __KERNEL_INTERRUPT_H$/;"	d
__KERNEL_MEMORY_H	kernel/memory.h	/^#define __KERNEL_MEMORY_H$/;"	d
__KERNEL_SHELL_H	shell/shell.h	/^#define __KERNEL_SHELL_H$/;"	d
__LIB_IO_H	lib/kernel/io.h	/^#define __LIB_IO_H$/;"	d
__LIB_KERNEL_BITMAP_H	lib/kernel/bitmap.h	/^#define __LIB_KERNEL_BITMAP_H$/;"	d
__LIB_KERNEL_LIST_H	lib/kernel/list.h	/^#define __LIB_KERNEL_LIST_H$/;"	d
__LIB_KERNEL_PRINT_H	lib/kernel/print.h	/^#define __LIB_KERNEL_PRINT_H$/;"	d
__LIB_KERNEL_STDIOSYS_H	lib/kernel/stdio-kernel.h	/^#define __LIB_KERNEL_STDIOSYS_H$/;"	d
__LIB_STDINT_H	lib/stdint.h	/^#define __LIB_STDINT_H$/;"	d
__LIB_STDIO_H	lib/stdio.h	/^#define __LIB_STDIO_H$/;"	d
__LIB_STRING_H	lib/string.h	/^#define __LIB_STRING_H$/;"	d
__LIB_USER_ASSERT_H	lib/user/assert.h	/^#define __LIB_USER_ASSERT_H$/;"	d
__LIB_USER_SYSCALL_H	lib/user/syscall.h	/^#define __LIB_USER_SYSCALL_H$/;"	d
__SHELL_BUILDIN_CMD_H	shell/buildin_cmd.h	/^#define __SHELL_BUILDIN_CMD_H$/;"	d
__SHELL_PIPE_H	shell/pipe.h	/^#define __SHELL_PIPE_H$/;"	d
__THREAD_SYNC_H	thread/sync.h	/^#define __THREAD_SYNC_H$/;"	d
__THREAD_THREAD_H	thread/thread.h	/^#define __THREAD_THREAD_H$/;"	d
__USERPROG_EXEC_H	userprog/exec.h	/^#define __USERPROG_EXEC_H$/;"	d
__USERPROG_FORK_H	userprog/fork.h	/^#define __USERPROG_FORK_H$/;"	d
__USERPROG_PROCESS_H	userprog/process.h	/^#define __USERPROG_PROCESS_H /;"	d
__USERPROG_SYSCALLINIT_H	userprog/syscall-init.h	/^#define __USERPROG_SYSCALLINIT_H$/;"	d
__USERPROG_TSS_H	userprog/tss.h	/^#define __USERPROG_TSS_H$/;"	d
__USERPROG_WAITEXIT_H	userprog/wait_exit.h	/^#define __USERPROG_WAITEXIT_H$/;"	d
_start	command/start.S	/^_start:$/;"	l
_syscall0	lib/user/syscall.c	/^#define _syscall0(/;"	d	file:
_syscall1	lib/user/syscall.c	/^#define _syscall1(/;"	d	file:
_syscall2	lib/user/syscall.c	/^#define _syscall2(/;"	d	file:
_syscall3	lib/user/syscall.c	/^#define _syscall3(/;"	d	file:
add	boot/loader.S	/^   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置$/;"	d
addr_v2p	kernel/memory.c	/^uint32_t addr_v2p(uint32_t vaddr) {$/;"	f	typeref:typename:uint32_t
all	makefile	/^all: clean mk_dir mk_img disk_img build hd ctags $/;"	t
all_list_tag	thread/thread.h	/^   struct list_elem all_list_tag;$/;"	m	struct:task_struct	typeref:struct:list_elem
allocate_pid	thread/thread.c	/^static pid_t allocate_pid(void) {$/;"	f	typeref:typename:pid_t	file:
alt_l_char	device/keyboard.c	/^#define alt_l_char	/;"	d	file:
alt_l_make	device/keyboard.c	/^#define alt_l_make /;"	d	file:
alt_r_break	device/keyboard.c	/^#define alt_r_break /;"	d	file:
alt_r_char	device/keyboard.c	/^#define alt_r_char	/;"	d	file:
alt_r_make	device/keyboard.c	/^#define alt_r_make /;"	d	file:
alt_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	typeref:typename:bool	file:
ards_nr	boot/loader.S	/^   ards_nr dw 0		      ;用于记录ards结构体数量$/;"	d
arena	kernel/memory.c	/^struct arena {$/;"	s	file:
arena2block	kernel/memory.c	/^static struct mem_block* arena2block(struct arena* a, uint32_t idx) {$/;"	f	typeref:struct:mem_block *	file:
argc	shell/shell.c	/^int32_t argc = -1;$/;"	v	typeref:typename:int32_t
argv	shell/shell.c	/^char* argv[MAX_ARG_NR] = {NULL};$/;"	v	typeref:typename:char * []
assert	lib/user/assert.h	/^   #define assert(/;"	d
attr_low_byte	kernel/global.h	/^   uint8_t  attr_low_byte;$/;"	m	struct:gdt_desc	typeref:typename:uint8_t
attribute	kernel/interrupt.c	/^   uint8_t     attribute;$/;"	m	struct:gate_desc	typeref:typename:uint8_t	file:
backlink	userprog/tss.c	/^    uint32_t backlink;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
backspace	device/keyboard.c	/^#define backspace	/;"	d	file:
base_high_byte	kernel/global.h	/^   uint8_t  base_high_byte;$/;"	m	struct:gdt_desc	typeref:typename:uint8_t
base_low_word	kernel/global.h	/^   uint16_t base_low_word;$/;"	m	struct:gdt_desc	typeref:typename:uint16_t
base_mid_byte	kernel/global.h	/^   uint8_t  base_mid_byte;$/;"	m	struct:gdt_desc	typeref:typename:uint8_t
bitmap	lib/kernel/bitmap.h	/^struct bitmap {$/;"	s
bitmap_init	lib/kernel/bitmap.c	/^void bitmap_init(struct bitmap* btmp) {$/;"	f	typeref:typename:void
bitmap_scan	lib/kernel/bitmap.c	/^int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {$/;"	f	typeref:typename:int
bitmap_scan_test	lib/kernel/bitmap.c	/^bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {$/;"	f	typeref:typename:bool
bitmap_set	lib/kernel/bitmap.c	/^void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {$/;"	f	typeref:typename:void
bitmap_sync	fs/file.c	/^void bitmap_sync(struct partition* part, uint32_t bit_idx, uint8_t btmp_type) {$/;"	f	typeref:typename:void
bitmap_type	fs/file.h	/^enum bitmap_type {$/;"	g
bits	lib/kernel/bitmap.h	/^   uint8_t* bits;$/;"	m	struct:bitmap	typeref:typename:uint8_t *
block2arena	kernel/memory.c	/^static struct arena* block2arena(struct mem_block* b) {$/;"	f	typeref:struct:arena *	file:
block_bitmap	device/ide.h	/^   struct bitmap block_bitmap;	 \/\/ 块位图$/;"	m	struct:partition	typeref:struct:bitmap
block_bitmap_alloc	fs/file.c	/^int32_t block_bitmap_alloc(struct partition* part) {$/;"	f	typeref:typename:int32_t
block_bitmap_lba	fs/super_block.h	/^   uint32_t block_bitmap_lba;	    \/\/ 块位图本身起始扇区地址$/;"	m	struct:super_block	typeref:typename:uint32_t
block_bitmap_sects	fs/super_block.h	/^   uint32_t block_bitmap_sects;     \/\/ 扇区位图本身占用的扇区数量$/;"	m	struct:super_block	typeref:typename:uint32_t
block_desc_init	kernel/memory.c	/^void block_desc_init(struct mem_block_desc* desc_array) {				   $/;"	f	typeref:typename:void
block_size	kernel/memory.h	/^   uint32_t block_size;		 \/\/ 内存块大小$/;"	m	struct:mem_block_desc	typeref:typename:uint32_t
blocks_per_arena	kernel/memory.h	/^   uint32_t blocks_per_arena;	 \/\/ 本arena中可容纳此mem_block的数量.$/;"	m	struct:mem_block_desc	typeref:typename:uint32_t
bool	kernel/global.h	/^#define bool /;"	d
boot_sector	device/ide.c	/^struct boot_sector {$/;"	s	file:
bootable	device/ide.c	/^    uint8_t  bootable;		 \/\/ 是否可引导	$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
btmp_bytes_len	lib/kernel/bitmap.h	/^   uint32_t btmp_bytes_len;$/;"	m	struct:bitmap	typeref:typename:uint32_t
buf	device/ioqueue.h	/^    char buf[bufsize];			    \/\/ 缓冲区大小$/;"	m	struct:ioqueue	typeref:typename:char[]
bufsize	device/ioqueue.h	/^#define bufsize /;"	d
build	makefile	/^build: $(BUILD_DIR)\/kernel.bin $(BUILD_DIR)\/mbr.bin $(BUILD_DIR)\/loader.bin$/;"	t
build_child_stack	userprog/fork.c	/^static int32_t build_child_stack(struct task_struct* child_thread) {$/;"	f	typeref:typename:int32_t	file:
buildin_cd	shell/buildin_cmd.c	/^char* buildin_cd(uint32_t argc, char** argv) {$/;"	f	typeref:typename:char *
buildin_clear	shell/buildin_cmd.c	/^void buildin_clear(uint32_t argc, char** argv UNUSED) {$/;"	f	typeref:typename:void
buildin_help	shell/buildin_cmd.c	/^void buildin_help(uint32_t argc UNUSED, char** argv UNUSED) {$/;"	f	typeref:typename:void
buildin_ls	shell/buildin_cmd.c	/^void buildin_ls(uint32_t argc, char** argv) {$/;"	f	typeref:typename:void
buildin_mkdir	shell/buildin_cmd.c	/^int32_t buildin_mkdir(uint32_t argc, char** argv) {$/;"	f	typeref:typename:int32_t
buildin_ps	shell/buildin_cmd.c	/^void buildin_ps(uint32_t argc, char** argv UNUSED) {$/;"	f	typeref:typename:void
buildin_pwd	shell/buildin_cmd.c	/^void buildin_pwd(uint32_t argc, char** argv UNUSED) {$/;"	f	typeref:typename:void
buildin_rm	shell/buildin_cmd.c	/^int32_t buildin_rm(uint32_t argc, char** argv) {$/;"	f	typeref:typename:int32_t
buildin_rmdir	shell/buildin_cmd.c	/^int32_t buildin_rmdir(uint32_t argc, char** argv) {$/;"	f	typeref:typename:int32_t
busy_wait	device/ide.c	/^static bool busy_wait(struct disk* hd) {$/;"	f	typeref:typename:bool	file:
caps_lock_char	device/keyboard.c	/^#define caps_lock_char	/;"	d	file:
caps_lock_make	device/keyboard.c	/^#define caps_lock_make /;"	d	file:
caps_lock_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	typeref:typename:bool	file:
channel_cnt	device/ide.c	/^uint8_t channel_cnt;	   \/\/ 按硬盘数计算的通道数$/;"	v	typeref:typename:uint8_t
channels	device/ide.c	/^struct ide_channel channels[2];	 \/\/ 有两个ide通道$/;"	v	typeref:struct:ide_channel[2]
char_invisible	device/keyboard.c	/^#define char_invisible	/;"	d	file:
chdir	lib/user/syscall.c	/^int32_t chdir(const char* path) {$/;"	f	typeref:typename:int32_t
clean	makefile	/^clean:$/;"	t
clear	lib/user/syscall.c	/^void clear(void) {$/;"	f	typeref:typename:void
clear_page_dir	boot/loader.S	/^.clear_page_dir:$/;"	l
close	lib/user/syscall.c	/^int32_t close(int32_t fd) {$/;"	f	typeref:typename:int32_t
closedir	lib/user/syscall.c	/^int32_t closedir(struct dir* dir) {$/;"	f	typeref:typename:int32_t
cls	lib/kernel/print.S	/^ .cls:$/;"	l
cls_screen	lib/kernel/print.S	/^cls_screen:$/;"	l
cmd_execute	shell/shell.c	/^static void cmd_execute(uint32_t argc, char** argv) {$/;"	f	typeref:typename:void	file:
cmd_line	shell/shell.c	/^static char cmd_line[MAX_PATH_LEN] = {0};$/;"	v	typeref:typename:char[]	file:
cmd_out	device/ide.c	/^static void cmd_out(struct ide_channel* channel, uint8_t cmd) {$/;"	f	typeref:typename:void	file:
cmd_parse	shell/shell.c	/^static int32_t cmd_parse(char* cmd_str, char** argv, char token) {$/;"	f	typeref:typename:int32_t	file:
cnt	kernel/memory.c	/^   uint32_t cnt;$/;"	m	struct:arena	typeref:typename:uint32_t	file:
console_acquire	device/console.c	/^void console_acquire() {$/;"	f	typeref:typename:void
console_init	device/console.c	/^void console_init() {$/;"	f	typeref:typename:void
console_lock	device/console.c	/^static struct lock console_lock;    \/\/ 控制台锁$/;"	v	typeref:struct:lock	file:
console_put_char	device/console.c	/^void console_put_char(uint8_t char_asci) {$/;"	f	typeref:typename:void
console_put_int	device/console.c	/^void console_put_int(uint32_t num) {$/;"	f	typeref:typename:void
console_put_str	device/console.c	/^void console_put_str(char* str) {$/;"	f	typeref:typename:void
console_release	device/console.c	/^void console_release() {$/;"	f	typeref:typename:void
consumer	device/ioqueue.h	/^    struct task_struct* consumer;$/;"	m	struct:ioqueue	typeref:struct:task_struct *
copy_body_stack3	userprog/fork.c	/^static void copy_body_stack3(struct task_struct* child_thread, struct task_struct* parent_thread/;"	f	typeref:typename:void	file:
copy_pcb_vaddrbitmap_stack0	userprog/fork.c	/^static int32_t copy_pcb_vaddrbitmap_stack0(struct task_struct* child_thread, struct task_struct*/;"	f	typeref:typename:int32_t	file:
copy_process	userprog/fork.c	/^static int32_t copy_process(struct task_struct* child_thread, struct task_struct* parent_thread)/;"	f	typeref:typename:int32_t	file:
cr3	userprog/tss.c	/^    uint32_t cr3;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
create_dir_entry	fs/dir.c	/^void create_dir_entry(char* filename, uint32_t inode_no, uint8_t file_type, struct dir_entry* p_/;"	f	typeref:typename:void
create_kernel_pde	boot/loader.S	/^.create_kernel_pde:$/;"	l
create_page_dir	userprog/process.c	/^uint32_t* create_page_dir(void) {$/;"	f	typeref:typename:uint32_t *
create_pde	boot/loader.S	/^.create_pde:				     ; 创建Page Directory Entry$/;"	l
create_pte	boot/loader.S	/^.create_pte:				     ; 创建Page Table Entry$/;"	l
create_user_vaddr_bitmap	userprog/process.c	/^void create_user_vaddr_bitmap(struct task_struct* user_prog) {$/;"	f	typeref:typename:void
cs	thread/thread.h	/^    uint32_t cs;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
cs	userprog/tss.c	/^    uint32_t cs;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ctags	makefile	/^ctags:$/;"	t
ctrl_l_char	device/keyboard.c	/^#define ctrl_l_char	/;"	d	file:
ctrl_l_make	device/keyboard.c	/^#define ctrl_l_make /;"	d	file:
ctrl_r_break	device/keyboard.c	/^#define ctrl_r_break /;"	d	file:
ctrl_r_char	device/keyboard.c	/^#define ctrl_r_char	/;"	d	file:
ctrl_r_make	device/keyboard.c	/^#define ctrl_r_make /;"	d	file:
ctrl_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	typeref:typename:bool	file:
cur_part	fs/fs.c	/^struct partition* cur_part;	 \/\/ 默认情况下操作的是哪个分区$/;"	v	typeref:struct:partition *
cwd_cache	shell/shell.c	/^char cwd_cache[MAX_PATH_LEN] = {0};$/;"	v	typeref:typename:char[]
cwd_inode_nr	thread/thread.h	/^   uint32_t cwd_inode_nr;	 \/\/ 进程所在的工作目录的inode编号$/;"	m	struct:task_struct	typeref:typename:uint32_t
data_start_lba	fs/super_block.h	/^   uint32_t data_start_lba;	    \/\/ 数据区开始的第一个扇区号$/;"	m	struct:super_block	typeref:typename:uint32_t
dcount	kernel/interrupt.c	/^   uint8_t     dcount;   \/\/此项为双字计数字段，是门描述符中的第4字节。此/;"	m	struct:gate_desc	typeref:typename:uint8_t	file:
default_prio	userprog/process.h	/^#define default_prio /;"	d
delete	device/keyboard.c	/^#define delete	/;"	d	file:
delete_dir_entry	fs/dir.c	/^bool delete_dir_entry(struct partition* part, struct dir* pdir, uint32_t inode_no, void* io_buf)/;"	f	typeref:typename:bool
desc	kernel/memory.c	/^   struct mem_block_desc* desc;	 \/\/ 此arena关联的mem_block_desc$/;"	m	struct:arena	typeref:struct:mem_block_desc *	file:
dev_no	device/ide.h	/^   uint8_t dev_no;			   \/\/ 本硬盘是主0还是从1$/;"	m	struct:disk	typeref:typename:uint8_t
devices	device/ide.h	/^   struct disk devices[2];	 \/\/ 一个通道上连接两个硬盘，一主一从$/;"	m	struct:ide_channel	typeref:struct:disk[2]
dir	fs/dir.h	/^struct dir {$/;"	s
dir_buf	fs/dir.h	/^   uint8_t dir_buf[512];  \/\/ 目录的数据缓存$/;"	m	struct:dir	typeref:typename:uint8_t[512]
dir_close	fs/dir.c	/^void dir_close(struct dir* dir) {$/;"	f	typeref:typename:void
dir_entry	fs/dir.h	/^struct dir_entry {$/;"	s
dir_entry_size	fs/super_block.h	/^   uint32_t dir_entry_size;	    \/\/ 目录项大小$/;"	m	struct:super_block	typeref:typename:uint32_t
dir_is_empty	fs/dir.c	/^bool dir_is_empty(struct dir* dir) {$/;"	f	typeref:typename:bool
dir_open	fs/dir.c	/^struct dir* dir_open(struct partition* part, uint32_t inode_no) {$/;"	f	typeref:struct:dir *
dir_pos	fs/dir.h	/^   uint32_t dir_pos;	  \/\/ 记录在目录内的偏移$/;"	m	struct:dir	typeref:typename:uint32_t
dir_read	fs/dir.c	/^struct dir_entry* dir_read(struct dir* dir) {$/;"	f	typeref:struct:dir_entry *
dir_remove	fs/dir.c	/^int32_t dir_remove(struct dir* parent_dir, struct dir* child_dir) {$/;"	f	typeref:typename:int32_t
disk	device/ide.h	/^struct disk {$/;"	s
disk_done	device/ide.h	/^   struct semaphore disk_done;	 \/\/ 硬盘处理完成.线程用这个信号量来阻塞自己，/;"	m	struct:ide_channel	typeref:struct:semaphore
disk_img	makefile	/^disk_img:$/;"	t
ds	thread/thread.h	/^    uint32_t ds;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
ds	userprog/tss.c	/^    uint32_t ds;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
e801_failed_so_try88	boot/loader.S	/^.e801_failed_so_try88: $/;"	l
e820_failed_so_try_e801	boot/loader.S	/^.e820_failed_so_try_e801:$/;"	l
e820_mem_get_loop	boot/loader.S	/^.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构$/;"	l
e_ehsize	userprog/exec.c	/^   Elf32_Half    e_ehsize;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_entry	userprog/exec.c	/^   Elf32_Addr    e_entry;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Addr	file:
e_flags	userprog/exec.c	/^   Elf32_Word    e_flags;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Word	file:
e_ident	userprog/exec.c	/^   unsigned char e_ident[16];$/;"	m	struct:Elf32_Ehdr	typeref:typename:unsigned char[16]	file:
e_machine	userprog/exec.c	/^   Elf32_Half    e_machine;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_phentsize	userprog/exec.c	/^   Elf32_Half    e_phentsize;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_phnum	userprog/exec.c	/^   Elf32_Half    e_phnum;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_phoff	userprog/exec.c	/^   Elf32_Off     e_phoff;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Off	file:
e_shentsize	userprog/exec.c	/^   Elf32_Half    e_shentsize;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_shnum	userprog/exec.c	/^   Elf32_Half    e_shnum;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_shoff	userprog/exec.c	/^   Elf32_Off     e_shoff;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Off	file:
e_shstrndx	userprog/exec.c	/^   Elf32_Half    e_shstrndx;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_type	userprog/exec.c	/^   Elf32_Half    e_type;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Half	file:
e_version	userprog/exec.c	/^   Elf32_Word    e_version;$/;"	m	struct:Elf32_Ehdr	typeref:typename:Elf32_Word	file:
each_segment	boot/loader.S	/^.each_segment:$/;"	l
eax	thread/thread.h	/^    uint32_t eax;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
eax	userprog/tss.c	/^    uint32_t eax;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ebp	thread/thread.h	/^    uint32_t ebp;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
ebp	thread/thread.h	/^   uint32_t ebp;$/;"	m	struct:thread_stack	typeref:typename:uint32_t
ebp	userprog/tss.c	/^    uint32_t ebp;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ebx	thread/thread.h	/^    uint32_t ebx;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
ebx	thread/thread.h	/^   uint32_t ebx;$/;"	m	struct:thread_stack	typeref:typename:uint32_t
ebx	userprog/tss.c	/^    uint32_t ebx;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ecx	thread/thread.h	/^    uint32_t ecx;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
ecx	userprog/tss.c	/^    uint32_t ecx;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
edi	thread/thread.h	/^    uint32_t edi;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
edi	thread/thread.h	/^   uint32_t edi;$/;"	m	struct:thread_stack	typeref:typename:uint32_t
edi	userprog/tss.c	/^    uint32_t edi;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
edx	thread/thread.h	/^    uint32_t edx;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
edx	userprog/tss.c	/^    uint32_t edx;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
eflags	thread/thread.h	/^    uint32_t eflags;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
eflags	userprog/tss.c	/^    uint32_t eflags;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
eip	thread/thread.h	/^    void (*eip) (void);$/;"	m	struct:intr_stack	typeref:typename:void (*)(void)
eip	thread/thread.h	/^   void (*eip) (thread_func* func, void* func_arg);$/;"	m	struct:thread_stack	typeref:typename:void (*)(thread_func * func,void * func_arg)
eip	userprog/tss.c	/^    uint32_t (*eip) (void);$/;"	m	struct:tss	typeref:typename:uint32_t (*)(void)	file:
elapsed_ticks	thread/thread.h	/^   uint32_t elapsed_ticks;$/;"	m	struct:task_struct	typeref:typename:uint32_t
elem2entry	lib/kernel/list.h	/^#define elem2entry(/;"	d
elem2thread_info	thread/thread.c	/^static bool elem2thread_info(struct list_elem* pelem, int arg UNUSED) {$/;"	f	typeref:typename:bool	file:
elem_find	lib/kernel/list.c	/^bool elem_find(struct list* plist, struct list_elem* obj_elem) {$/;"	f	typeref:typename:bool
end_chs	device/ide.c	/^    uint8_t  end_chs;		 \/\/ 结束柱面号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
end_head	device/ide.c	/^    uint8_t  end_head;		 \/\/ 结束磁头号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
end_sec	device/ide.c	/^    uint8_t  end_sec;		 \/\/ 结束扇区号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
enter	device/keyboard.c	/^#define enter	/;"	d	file:
enter_kernel	boot/loader.S	/^enter_kernel:    $/;"	l
err_code	thread/thread.h	/^    uint32_t err_code;		 \/\/ err_code会被压入在eip之后$/;"	m	struct:intr_stack	typeref:typename:uint32_t
error_hlt	boot/loader.S	/^.error_hlt:		      ;出错则挂起$/;"	l
es	thread/thread.h	/^    uint32_t es;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
es	userprog/tss.c	/^    uint32_t es;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
esc	device/keyboard.c	/^#define esc	/;"	d	file:
esi	thread/thread.h	/^    uint32_t esi;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
esi	thread/thread.h	/^   uint32_t esi;$/;"	m	struct:thread_stack	typeref:typename:uint32_t
esi	userprog/tss.c	/^    uint32_t esi;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
esp	thread/thread.h	/^    void* esp;$/;"	m	struct:intr_stack	typeref:typename:void *
esp	userprog/tss.c	/^    uint32_t esp;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
esp0	userprog/tss.c	/^    uint32_t* esp0;$/;"	m	struct:tss	typeref:typename:uint32_t *	file:
esp1	userprog/tss.c	/^    uint32_t* esp1;$/;"	m	struct:tss	typeref:typename:uint32_t *	file:
esp2	userprog/tss.c	/^    uint32_t* esp2;$/;"	m	struct:tss	typeref:typename:uint32_t *	file:
esp_dummy	thread/thread.h	/^    uint32_t esp_dummy;	 \/\/ 虽然pushad把esp也压入,但esp是不断变化的,所以会被p/;"	m	struct:intr_stack	typeref:typename:uint32_t
exception_init	kernel/interrupt.c	/^static void exception_init(void) {			    \/\/ 完成一般中断处理函数注册及异常名称/;"	f	typeref:typename:void	file:
execv	lib/user/syscall.c	/^int32_t execv(const char* pathname, char** argv) {$/;"	f	typeref:typename:int32_t
exit	lib/user/syscall.c	/^void exit(int32_t status) {$/;"	f	typeref:typename:void
exit_status	thread/thread.h	/^   int8_t  exit_status;         \/\/ 进程结束时自己调用exit传入的参数$/;"	m	struct:task_struct	typeref:typename:int8_t
expecting_intr	device/ide.h	/^   bool expecting_intr;		 \/\/ 向硬盘发完命令后等待来自硬盘的中断$/;"	m	struct:ide_channel	typeref:typename:bool
ext_lba_base	device/ide.c	/^int32_t ext_lba_base = 0;$/;"	v	typeref:typename:int32_t
ext_scancode	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	typeref:typename:bool	file:
extern	command/start.S	/^extern	 exit $/;"	l
extern	command/start.S	/^extern	 main$/;"	l
extern	kernel/kernel.S	/^extern idt_table		 ;idt_table是C中注册的中断处理程序数组$/;"	l
extern	kernel/kernel.S	/^extern syscall_table$/;"	l
f_type	fs/dir.h	/^   enum file_types f_type;	      \/\/ 文件类型$/;"	m	struct:dir_entry	typeref:enum:file_types
false	kernel/global.h	/^#define false /;"	d
fd_flag	fs/file.h	/^   uint32_t fd_flag;$/;"	m	struct:file	typeref:typename:uint32_t
fd_inode	fs/file.h	/^   struct inode* fd_inode;$/;"	m	struct:file	typeref:struct:inode *
fd_local2global	fs/fs.c	/^uint32_t fd_local2global(uint32_t local_fd) {$/;"	f	typeref:typename:uint32_t
fd_pos	fs/file.h	/^   uint32_t fd_pos;      \/\/ 记录当前文件操作的偏移地址,以0为起始,最大为文/;"	m	struct:file	typeref:typename:uint32_t
fd_redirect	lib/user/syscall.c	/^void fd_redirect(uint32_t old_local_fd, uint32_t new_local_fd) {$/;"	f	typeref:typename:void
fd_table	thread/thread.h	/^   int32_t fd_table[MAX_FILES_OPEN_PER_PROC];	\/\/ 已打开文件数组$/;"	m	struct:task_struct	typeref:typename:int32_t[]
file	fs/file.h	/^struct file {$/;"	s
file_close	fs/file.c	/^int32_t file_close(struct file* file) {$/;"	f	typeref:typename:int32_t
file_create	fs/file.c	/^int32_t file_create(struct dir* parent_dir, char* filename, uint8_t flag) {$/;"	f	typeref:typename:int32_t
file_open	fs/file.c	/^int32_t file_open(uint32_t inode_no, uint8_t flag) {$/;"	f	typeref:typename:int32_t
file_read	fs/file.c	/^int32_t file_read(struct file* file, void* buf, uint32_t count) {$/;"	f	typeref:typename:int32_t
file_table	fs/file.c	/^struct file file_table[MAX_FILE_OPEN];$/;"	v	typeref:struct:file[]
file_type	fs/fs.h	/^   enum file_types file_type;		    \/\/ 找到的是普通文件还是目录,找不到将为未知/;"	m	struct:path_search_record	typeref:enum:file_types
file_types	fs/fs.h	/^enum file_types {$/;"	g
file_write	fs/file.c	/^int32_t file_write(struct file* file, const void* buf, uint32_t count) {$/;"	f	typeref:typename:int32_t
filename	fs/dir.h	/^   char filename[MAX_FILE_NAME_LEN];  \/\/ 普通文件或目录名称$/;"	m	struct:dir_entry	typeref:typename:char[]
filesys_init	fs/fs.c	/^void filesys_init() {$/;"	f	typeref:typename:void
final_path	shell/shell.c	/^char final_path[MAX_PATH_LEN] = {0};      \/\/ 用于洗路径时的缓冲$/;"	v	typeref:typename:char[]
find_child	userprog/wait_exit.c	/^static bool find_child(struct list_elem* pelem, int32_t ppid) {$/;"	f	typeref:typename:bool	file:
find_hanging_child	userprog/wait_exit.c	/^static bool find_hanging_child(struct list_elem* pelem, int32_t ppid) {$/;"	f	typeref:typename:bool	file:
find_max_mem_area	boot/loader.S	/^.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用$/;"	l
fork	lib/user/syscall.c	/^pid_t fork(void){$/;"	f	typeref:typename:pid_t
fork_pid	thread/thread.c	/^pid_t fork_pid(void) {$/;"	f	typeref:typename:pid_t
free	lib/user/syscall.c	/^void free(void* ptr) {$/;"	f	typeref:typename:void
free_a_phy_page	kernel/memory.c	/^void free_a_phy_page(uint32_t pg_phy_addr) {$/;"	f	typeref:typename:void
free_elem	kernel/memory.h	/^   struct list_elem free_elem;$/;"	m	struct:mem_block	typeref:struct:list_elem
free_list	kernel/memory.h	/^   struct list free_list;	 \/\/ 目前可用的mem_block链表$/;"	m	struct:mem_block_desc	typeref:struct:list
frequency_set	device/timer.c	/^static void frequency_set(uint8_t counter_port, \\$/;"	f	typeref:typename:void	file:
fs	thread/thread.h	/^    uint32_t fs;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
fs	userprog/tss.c	/^    uint32_t fs;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
fs_type	device/ide.c	/^    uint8_t  fs_type;		 \/\/ 分区类型$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
full0	lib/kernel/print.S	/^.full0:$/;"	l
func_arg	thread/thread.h	/^   void* func_arg;    \/\/ 由Kernel_thread所调用的函数所需的参数$/;"	m	struct:thread_stack	typeref:typename:void *
func_offset_high_word	kernel/interrupt.c	/^   uint16_t    func_offset_high_word;$/;"	m	struct:gate_desc	typeref:typename:uint16_t	file:
func_offset_low_word	kernel/interrupt.c	/^   uint16_t    func_offset_low_word;$/;"	m	struct:gate_desc	typeref:typename:uint16_t	file:
function	lib/kernel/list.h	/^typedef bool (function)(struct list_elem*, int arg);$/;"	t	typeref:typename:bool ()(struct list_elem *,int arg)
function	thread/thread.h	/^   thread_func* function;   \/\/ 由Kernel_thread所调用的函数名$/;"	m	struct:thread_stack	typeref:typename:thread_func *
gate_desc	kernel/interrupt.c	/^struct gate_desc {$/;"	s	file:
gdt_desc	kernel/global.h	/^struct gdt_desc {$/;"	s
gdt_ptr	boot/loader.S	/^   gdt_ptr  dw  GDT_LIMIT $/;"	d
general_intr_handler	kernel/interrupt.c	/^static void general_intr_handler(uint8_t vec_nr) {$/;"	f	typeref:typename:void	file:
general_tag	thread/thread.h	/^   struct list_elem general_tag;				    $/;"	m	struct:task_struct	typeref:struct:list_elem
get_a_page	kernel/memory.c	/^void* get_a_page(enum pool_flags pf, uint32_t vaddr) {$/;"	f	typeref:typename:void *
get_a_page_without_opvaddrbitmap	kernel/memory.c	/^void* get_a_page_without_opvaddrbitmap(enum pool_flags pf, uint32_t vaddr) {$/;"	f	typeref:typename:void *
get_child_dir_name	fs/fs.c	/^static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf/;"	f	typeref:typename:int	file:
get_free_slot_in_global	fs/file.c	/^int32_t get_free_slot_in_global(void) {$/;"	f	typeref:typename:int32_t
get_kernel_pages	kernel/memory.c	/^void* get_kernel_pages(uint32_t pg_cnt) {$/;"	f	typeref:typename:void *
get_parent_dir_inode_nr	fs/fs.c	/^static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void* io_buf) {$/;"	f	typeref:typename:uint32_t	file:
get_user_pages	kernel/memory.c	/^void* get_user_pages(uint32_t pg_cnt) {$/;"	f	typeref:typename:void *
getcwd	lib/user/syscall.c	/^char* getcwd(char* buf, uint32_t size) {$/;"	f	typeref:typename:char *
getpid	lib/user/syscall.c	/^uint32_t getpid() {$/;"	f	typeref:typename:uint32_t
global	command/start.S	/^global _start$/;"	l
global	kernel/kernel.S	/^global intr_entry_table$/;"	l
global	kernel/kernel.S	/^global intr_exit$/;"	l
global	kernel/kernel.S	/^global syscall_handler$/;"	l
global	lib/kernel/print.S	/^global cls_screen$/;"	l
global	lib/kernel/print.S	/^global put_char$/;"	l
global	lib/kernel/print.S	/^global put_int$/;"	l
global	lib/kernel/print.S	/^global put_str$/;"	l
global	lib/kernel/print.S	/^global set_cursor$/;"	l
global	thread/switch.S	/^global switch_to$/;"	l
go_on_read	boot/loader.S	/^  .go_on_read:$/;"	l
go_on_read	boot/mbr.S	/^  .go_on_read:$/;"	l
go_on_skip	lib/kernel/print.S	/^.go_on_skip:   $/;"	l
goon	lib/kernel/print.S	/^.goon:$/;"	l
gs	thread/thread.h	/^    uint32_t gs;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
gs	userprog/tss.c	/^    uint32_t gs;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
hd	makefile	/^hd:$/;"	t
head	device/ioqueue.h	/^    int32_t head;			    \/\/ 队首,数据往队首处写入$/;"	m	struct:ioqueue	typeref:typename:int32_t
head	lib/kernel/list.h	/^   struct list_elem head;$/;"	m	struct:list	typeref:struct:list_elem
help	lib/user/syscall.c	/^void help(void) {$/;"	f	typeref:typename:void
holder	thread/sync.h	/^   struct   task_struct* holder;	    \/\/ 锁的持有者$/;"	m	struct:lock	typeref:struct:task_struct *
holder_repeat_nr	thread/sync.h	/^   uint32_t holder_repeat_nr;		    \/\/ 锁的持有者重复申请锁的次数$/;"	m	struct:lock	typeref:typename:uint32_t
i_no	fs/dir.h	/^   uint32_t i_no;		      \/\/ 普通文件或目录对应的inode编号$/;"	m	struct:dir_entry	typeref:typename:uint32_t
i_no	fs/inode.h	/^   uint32_t i_no;    \/\/ inode编号$/;"	m	struct:inode	typeref:typename:uint32_t
i_open_cnts	fs/inode.h	/^   uint32_t i_open_cnts;   \/\/ 记录此文件被打开的次数$/;"	m	struct:inode	typeref:typename:uint32_t
i_sectors	fs/inode.h	/^   uint32_t i_sectors[13];$/;"	m	struct:inode	typeref:typename:uint32_t[13]
i_size	fs/inode.h	/^   uint32_t i_size;$/;"	m	struct:inode	typeref:typename:uint32_t
ide_channel	device/ide.h	/^struct ide_channel {$/;"	s
ide_init	device/ide.c	/^void ide_init() {$/;"	f	typeref:typename:void
ide_read	device/ide.c	/^void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {   \/\/ 此处的sec_/;"	f	typeref:typename:void
ide_write	device/ide.c	/^void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {$/;"	f	typeref:typename:void
identify_disk	device/ide.c	/^static void identify_disk(struct disk* hd) {$/;"	f	typeref:typename:void	file:
idle	thread/thread.c	/^static void idle(void* arg UNUSED) {$/;"	f	typeref:typename:void	file:
idle_thread	thread/thread.c	/^struct task_struct* idle_thread;    \/\/ idle线程$/;"	v	typeref:struct:task_struct *
idt	kernel/interrupt.c	/^static struct gate_desc idt[IDT_DESC_CNT];   \/\/ idt是中断描述符表,本质上就是个中/;"	v	typeref:struct:gate_desc[]	file:
idt_desc_init	kernel/interrupt.c	/^static void idt_desc_init(void) {$/;"	f	typeref:typename:void	file:
idt_init	kernel/interrupt.c	/^void idt_init() {$/;"	f	typeref:typename:void
idt_table	kernel/interrupt.c	/^intr_handler idt_table[IDT_DESC_CNT];$/;"	v	typeref:typename:intr_handler[]
inb	lib/kernel/io.h	/^static inline uint8_t inb(uint16_t port) {$/;"	f	typeref:typename:uint8_t
init	kernel/main.c	/^void init(void) {$/;"	f	typeref:typename:void
init_adopt_a_child	userprog/wait_exit.c	/^static bool init_adopt_a_child(struct list_elem* pelem, int32_t pid) {$/;"	f	typeref:typename:bool	file:
init_all	kernel/init.c	/^void init_all() {$/;"	f	typeref:typename:void
init_thread	thread/thread.c	/^void init_thread(struct task_struct* pthread, char* name, int prio) {$/;"	f	typeref:typename:void
inode	fs/dir.h	/^   struct inode* inode;   $/;"	m	struct:dir	typeref:struct:inode *
inode	fs/inode.h	/^struct inode {$/;"	s
inode_bitmap	device/ide.h	/^   struct bitmap inode_bitmap;	 \/\/ i结点位图$/;"	m	struct:partition	typeref:struct:bitmap
inode_bitmap_alloc	fs/file.c	/^int32_t inode_bitmap_alloc(struct partition* part) {$/;"	f	typeref:typename:int32_t
inode_bitmap_lba	fs/super_block.h	/^   uint32_t inode_bitmap_lba;	    \/\/ i结点位图起始扇区lba地址$/;"	m	struct:super_block	typeref:typename:uint32_t
inode_bitmap_sects	fs/super_block.h	/^   uint32_t inode_bitmap_sects;	    \/\/ i结点位图占用的扇区数量$/;"	m	struct:super_block	typeref:typename:uint32_t
inode_close	fs/inode.c	/^void inode_close(struct inode* inode) {$/;"	f	typeref:typename:void
inode_cnt	fs/super_block.h	/^   uint32_t inode_cnt;		    \/\/ 本分区中inode数量$/;"	m	struct:super_block	typeref:typename:uint32_t
inode_delete	fs/inode.c	/^void inode_delete(struct partition* part, uint32_t inode_no, void* io_buf) {$/;"	f	typeref:typename:void
inode_init	fs/inode.c	/^void inode_init(uint32_t inode_no, struct inode* new_inode) {$/;"	f	typeref:typename:void
inode_locate	fs/inode.c	/^static void inode_locate(struct partition* part, uint32_t inode_no, struct inode_position* inode/;"	f	typeref:typename:void	file:
inode_open	fs/inode.c	/^struct inode* inode_open(struct partition* part, uint32_t inode_no) {$/;"	f	typeref:struct:inode *
inode_position	fs/inode.c	/^struct inode_position {$/;"	s	file:
inode_release	fs/inode.c	/^void inode_release(struct partition* part, uint32_t inode_no) {$/;"	f	typeref:typename:void
inode_sync	fs/inode.c	/^void inode_sync(struct partition* part, struct inode* inode, void* io_buf) {	 \/\/ io_buf是用于/;"	f	typeref:typename:void
inode_table_lba	fs/super_block.h	/^   uint32_t inode_table_lba;	    \/\/ i结点表起始扇区lba地址$/;"	m	struct:super_block	typeref:typename:uint32_t
inode_table_sects	fs/super_block.h	/^   uint32_t inode_table_sects;	    \/\/ i结点表占用的扇区数量$/;"	m	struct:super_block	typeref:typename:uint32_t
inode_tag	fs/inode.h	/^   struct list_elem inode_tag;$/;"	m	struct:inode	typeref:struct:list_elem
insw	lib/kernel/io.h	/^static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {$/;"	f	typeref:typename:void
int16_t	lib/stdint.h	/^typedef signed short int int16_t;$/;"	t	typeref:typename:signed short int
int32_t	lib/stdint.h	/^typedef signed int int32_t;$/;"	t	typeref:typename:signed int
int64_t	lib/stdint.h	/^typedef signed long long int int64_t;$/;"	t	typeref:typename:signed long long int
int8_t	lib/stdint.h	/^typedef signed char int8_t;$/;"	t	typeref:typename:signed char
intr0x00entry	kernel/kernel.asm	/^intr0x00entry:$/;"	l
intr0x01entry	kernel/kernel.asm	/^intr0x01entry:$/;"	l
intr0x02entry	kernel/kernel.asm	/^intr0x02entry:$/;"	l
intr0x03entry	kernel/kernel.asm	/^intr0x03entry:$/;"	l
intr0x04entry	kernel/kernel.asm	/^intr0x04entry:$/;"	l
intr0x05entry	kernel/kernel.asm	/^intr0x05entry:$/;"	l
intr0x06entry	kernel/kernel.asm	/^intr0x06entry:$/;"	l
intr0x07entry	kernel/kernel.asm	/^intr0x07entry:$/;"	l
intr0x08entry	kernel/kernel.asm	/^intr0x08entry:$/;"	l
intr0x09entry	kernel/kernel.asm	/^intr0x09entry:$/;"	l
intr0x0aentry	kernel/kernel.asm	/^intr0x0aentry:$/;"	l
intr0x0bentry	kernel/kernel.asm	/^intr0x0bentry:$/;"	l
intr0x0centry	kernel/kernel.asm	/^intr0x0centry:$/;"	l
intr0x0dentry	kernel/kernel.asm	/^intr0x0dentry:$/;"	l
intr0x0eentry	kernel/kernel.asm	/^intr0x0eentry:$/;"	l
intr0x0fentry	kernel/kernel.asm	/^intr0x0fentry:$/;"	l
intr0x10entry	kernel/kernel.asm	/^intr0x10entry:$/;"	l
intr0x11entry	kernel/kernel.asm	/^intr0x11entry:$/;"	l
intr0x12entry	kernel/kernel.asm	/^intr0x12entry:$/;"	l
intr0x13entry	kernel/kernel.asm	/^intr0x13entry:$/;"	l
intr0x14entry	kernel/kernel.asm	/^intr0x14entry:$/;"	l
intr0x15entry	kernel/kernel.asm	/^intr0x15entry:$/;"	l
intr0x16entry	kernel/kernel.asm	/^intr0x16entry:$/;"	l
intr0x17entry	kernel/kernel.asm	/^intr0x17entry:$/;"	l
intr0x18entry	kernel/kernel.asm	/^intr0x18entry:$/;"	l
intr0x19entry	kernel/kernel.asm	/^intr0x19entry:$/;"	l
intr0x1aentry	kernel/kernel.asm	/^intr0x1aentry:$/;"	l
intr0x1bentry	kernel/kernel.asm	/^intr0x1bentry:$/;"	l
intr0x1centry	kernel/kernel.asm	/^intr0x1centry:$/;"	l
intr0x1dentry	kernel/kernel.asm	/^intr0x1dentry:$/;"	l
intr0x1eentry	kernel/kernel.asm	/^intr0x1eentry:$/;"	l
intr0x1fentry	kernel/kernel.asm	/^intr0x1fentry:$/;"	l
intr0x20entry	kernel/kernel.asm	/^intr0x20entry:$/;"	l
intr0x21entry	kernel/kernel.asm	/^intr0x21entry:$/;"	l
intr0x22entry	kernel/kernel.asm	/^intr0x22entry:$/;"	l
intr0x23entry	kernel/kernel.asm	/^intr0x23entry:$/;"	l
intr0x24entry	kernel/kernel.asm	/^intr0x24entry:$/;"	l
intr0x25entry	kernel/kernel.asm	/^intr0x25entry:$/;"	l
intr0x26entry	kernel/kernel.asm	/^intr0x26entry:$/;"	l
intr0x27entry	kernel/kernel.asm	/^intr0x27entry:$/;"	l
intr0x28entry	kernel/kernel.asm	/^intr0x28entry:$/;"	l
intr0x29entry	kernel/kernel.asm	/^intr0x29entry:$/;"	l
intr0x2aentry	kernel/kernel.asm	/^intr0x2aentry:$/;"	l
intr0x2bentry	kernel/kernel.asm	/^intr0x2bentry:$/;"	l
intr0x2centry	kernel/kernel.asm	/^intr0x2centry:$/;"	l
intr0x2dentry	kernel/kernel.asm	/^intr0x2dentry:$/;"	l
intr0x2eentry	kernel/kernel.asm	/^intr0x2eentry:$/;"	l
intr0x2fentry	kernel/kernel.asm	/^intr0x2fentry:$/;"	l
intr_disable	kernel/interrupt.c	/^enum intr_status intr_disable() {     $/;"	f	typeref:enum:intr_status
intr_enable	kernel/interrupt.c	/^enum intr_status intr_enable() {$/;"	f	typeref:enum:intr_status
intr_entry_table	kernel/kernel.S	/^intr_entry_table:$/;"	l
intr_entry_table	kernel/kernel.asm	/^intr_entry_table:$/;"	l
intr_exit	kernel/kernel.S	/^intr_exit:	     $/;"	l
intr_exit	kernel/kernel.asm	/^intr_exit:$/;"	l
intr_get_status	kernel/interrupt.c	/^enum intr_status intr_get_status() {$/;"	f	typeref:enum:intr_status
intr_handler	kernel/interrupt.h	/^typedef void* intr_handler;$/;"	t	typeref:typename:void *
intr_hd_handler	device/ide.c	/^void intr_hd_handler(uint8_t irq_no) {$/;"	f	typeref:typename:void
intr_keyboard_handler	device/keyboard.c	/^static void intr_keyboard_handler(void) {$/;"	f	typeref:typename:void	file:
intr_name	kernel/interrupt.c	/^char* intr_name[IDT_DESC_CNT];		     \/\/ 用于保存异常的名字$/;"	v	typeref:typename:char * []
intr_set_status	kernel/interrupt.c	/^enum intr_status intr_set_status(enum intr_status status) {$/;"	f	typeref:enum:intr_status
intr_stack	thread/thread.h	/^struct intr_stack {$/;"	s
intr_status	kernel/interrupt.h	/^enum intr_status {		 \/\/ 中断状态$/;"	g
intr_timer_handler	device/timer.c	/^static void intr_timer_handler(void) {$/;"	f	typeref:typename:void	file:
io_base	userprog/tss.c	/^    uint32_t io_base;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ioq_empty	device/ioqueue.c	/^static bool ioq_empty(struct ioqueue* ioq) {$/;"	f	typeref:typename:bool	file:
ioq_full	device/ioqueue.c	/^bool ioq_full(struct ioqueue* ioq) {$/;"	f	typeref:typename:bool
ioq_getchar	device/ioqueue.c	/^char ioq_getchar(struct ioqueue* ioq) {$/;"	f	typeref:typename:char
ioq_length	device/ioqueue.c	/^uint32_t ioq_length(struct ioqueue* ioq) {$/;"	f	typeref:typename:uint32_t
ioq_putchar	device/ioqueue.c	/^void ioq_putchar(struct ioqueue* ioq, char byte) {$/;"	f	typeref:typename:void
ioq_wait	device/ioqueue.c	/^static void ioq_wait(struct task_struct** waiter) {$/;"	f	typeref:typename:void	file:
ioqueue	device/ioqueue.h	/^struct ioqueue {$/;"	s
ioqueue_init	device/ioqueue.c	/^void ioqueue_init(struct ioqueue* ioq) {$/;"	f	typeref:typename:void
irq_no	device/ide.h	/^   uint8_t irq_no;		 \/\/ 本通道所用的中断号$/;"	m	struct:ide_channel	typeref:typename:uint8_t
is_A2F	lib/kernel/print.S	/^.is_A2F:$/;"	l
is_backspace	lib/kernel/print.S	/^ .is_backspace:		      $/;"	l
is_carriage_return	lib/kernel/print.S	/^ .is_carriage_return:			  ; 是回车符CR(\\r)$/;"	l
is_carriage_return_end	lib/kernel/print.S	/^ .is_carriage_return_end:                 ; 回车符CR处理结束$/;"	l
is_line_feed	lib/kernel/print.S	/^ .is_line_feed:				  ; 是换行符LF(\\n)$/;"	l
is_line_feed_end	lib/kernel/print.S	/^ .is_line_feed_end:			  ; 若是LF(\\n),将光标移+80便可。  $/;"	l
is_pipe	shell/pipe.c	/^bool is_pipe(uint32_t local_fd) {$/;"	f	typeref:typename:bool
itoa	lib/stdio.c	/^static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {$/;"	f	typeref:typename:void	file:
k_block_descs	kernel/memory.c	/^struct mem_block_desc k_block_descs[DESC_CNT];	\/\/ 内核内存块描述符数组$/;"	v	typeref:struct:mem_block_desc[]
kbd_buf	device/keyboard.c	/^struct ioqueue kbd_buf;	   \/\/ 定义键盘缓冲区$/;"	v	typeref:struct:ioqueue
kernel_init	boot/loader.S	/^kernel_init:$/;"	l
kernel_pool	kernel/memory.c	/^struct pool kernel_pool, user_pool;      \/\/ 生成内核内存池和用户内存池$/;"	v	typeref:struct:pool
kernel_thread	thread/thread.c	/^static void kernel_thread(thread_func* function, void* func_arg) {$/;"	f	typeref:typename:void	file:
kernel_vaddr	kernel/memory.c	/^struct virtual_addr kernel_vaddr;	 \/\/ 此结构是用来给内核分配虚拟地址$/;"	v	typeref:struct:virtual_addr
keyboard_init	device/keyboard.c	/^void keyboard_init() {$/;"	f	typeref:typename:void
keymap	device/keyboard.c	/^static char keymap[][2] = {$/;"	v	typeref:typename:char[][2]	file:
l_no	device/ide.c	/^uint8_t p_no = 0, l_no = 0;	 \/\/ 用来记录硬盘主分区和逻辑分区的下标$/;"	v	typeref:typename:uint8_t
large	kernel/memory.c	/^   bool large;		   $/;"	m	struct:arena	typeref:typename:bool	file:
ldt	userprog/tss.c	/^    uint32_t ldt;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
limit_high_attr_high	kernel/global.h	/^   uint8_t  limit_high_attr_high;$/;"	m	struct:gdt_desc	typeref:typename:uint8_t
limit_low_word	kernel/global.h	/^   uint16_t limit_low_word;$/;"	m	struct:gdt_desc	typeref:typename:uint16_t
list	lib/kernel/list.h	/^struct list {$/;"	s
list_append	lib/kernel/list.c	/^void list_append(struct list* plist, struct list_elem* elem) {$/;"	f	typeref:typename:void
list_elem	lib/kernel/list.h	/^struct list_elem {$/;"	s
list_empty	lib/kernel/list.c	/^bool list_empty(struct list* plist) {		\/\/ 判断队列是否为空$/;"	f	typeref:typename:bool
list_init	lib/kernel/list.c	/^void list_init (struct list* list) {$/;"	f	typeref:typename:void
list_insert_before	lib/kernel/list.c	/^void list_insert_before(struct list_elem* before, struct list_elem* elem) { $/;"	f	typeref:typename:void
list_len	lib/kernel/list.c	/^uint32_t list_len(struct list* plist) {$/;"	f	typeref:typename:uint32_t
list_pop	lib/kernel/list.c	/^struct list_elem* list_pop(struct list* plist) {$/;"	f	typeref:struct:list_elem *
list_push	lib/kernel/list.c	/^void list_push(struct list* plist, struct list_elem* elem) {$/;"	f	typeref:typename:void
list_remove	lib/kernel/list.c	/^void list_remove(struct list_elem* pelem) {$/;"	f	typeref:typename:void
list_traversal	lib/kernel/list.c	/^struct list_elem* list_traversal(struct list* plist, function func, int arg) {$/;"	f	typeref:struct:list_elem *
load	userprog/exec.c	/^static int32_t load(const char* pathname) {$/;"	f	typeref:typename:int32_t	file:
loader_start	boot/loader.S	/^   loader_start:$/;"	l
lock	device/ide.h	/^   struct lock lock;$/;"	m	struct:ide_channel	typeref:struct:lock
lock	device/ioqueue.h	/^    struct lock lock;$/;"	m	struct:ioqueue	typeref:struct:lock
lock	kernel/memory.c	/^   struct lock lock;		 \/\/ 申请内存时互斥$/;"	m	struct:pool	typeref:struct:lock	file:
lock	thread/sync.h	/^struct lock {$/;"	s
lock_acquire	thread/sync.c	/^void lock_acquire(struct lock* plock) {$/;"	f	typeref:typename:void
lock_init	thread/sync.c	/^void lock_init(struct lock* plock) {$/;"	f	typeref:typename:void
lock_release	thread/sync.c	/^void lock_release(struct lock* plock) {$/;"	f	typeref:typename:void
logic_parts	device/ide.h	/^   struct partition logic_parts[8];	   \/\/ 逻辑分区数量无限,但总得有个支持的上/;"	m	struct:disk	typeref:struct:partition[8]
lseek	lib/user/syscall.c	/^int32_t lseek(int32_t fd, int32_t offset, uint8_t whence) {$/;"	f	typeref:typename:int32_t
magic	fs/super_block.h	/^   uint32_t magic;		    \/\/ 用来标识文件系统类型,支持多文件系统的操作系统/;"	m	struct:super_block	typeref:typename:uint32_t
main	command/cat.c	/^int main(int argc, char** argv) {$/;"	f	typeref:typename:int
main	kernel/main.c	/^int main(void) {$/;"	f	typeref:typename:int
main_thread	thread/thread.c	/^struct task_struct* main_thread;    \/\/ 主线程PCB$/;"	v	typeref:struct:task_struct *
make_clear_abs_path	shell/buildin_cmd.c	/^void make_clear_abs_path(char* path, char* final_path) {$/;"	f	typeref:typename:void
make_gdt_desc	userprog/tss.c	/^static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint/;"	f	typeref:struct:gdt_desc	file:
make_idt_desc	kernel/interrupt.c	/^static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { $/;"	f	typeref:typename:void	file:
make_main_thread	thread/thread.c	/^static void make_main_thread(void) {$/;"	f	typeref:typename:void	file:
malloc	lib/user/syscall.c	/^void* malloc(uint32_t size) {$/;"	f	typeref:typename:void *
malloc_page	kernel/memory.c	/^void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {$/;"	f	typeref:typename:void *
max_lba	device/ide.c	/^#define max_lba /;"	d	file:
mem_block	kernel/memory.h	/^struct mem_block {$/;"	s
mem_block_desc	kernel/memory.h	/^struct mem_block_desc {$/;"	s
mem_cpy	boot/loader.S	/^mem_cpy:		      $/;"	l
mem_get_ok	boot/loader.S	/^.mem_get_ok:$/;"	l
mem_init	kernel/memory.c	/^void mem_init() {$/;"	f	typeref:typename:void
mem_pool_init	kernel/memory.c	/^static void mem_pool_init(uint32_t all_mem) {$/;"	f	typeref:typename:void	file:
memcmp	lib/string.c	/^int memcmp(const void* a_, const void* b_, uint32_t size) {$/;"	f	typeref:typename:int
memcpy	lib/string.c	/^void memcpy(void* dst_, const void* src_, uint32_t size) {$/;"	f	typeref:typename:void
memset	lib/string.c	/^void memset(void* dst_, uint8_t value, uint32_t size) {$/;"	f	typeref:typename:void
mfree_page	kernel/memory.c	/^void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {$/;"	f	typeref:typename:void
mil_seconds_per_intr	device/timer.c	/^#define mil_seconds_per_intr /;"	d	file:
mk_dir	makefile	/^mk_dir:$/;"	t
mk_img	makefile	/^mk_img:$/;"	t
mkdir	lib/user/syscall.c	/^int32_t mkdir(const char* pathname) {$/;"	f	typeref:typename:int32_t
mount_partition	fs/fs.c	/^static bool mount_partition(struct list_elem* pelem, int arg) {$/;"	f	typeref:typename:bool	file:
mov	boot/loader.S	/^      mov di,cx		   ; 备份扇区数到di$/;"	d
mov	boot/loader.S	/^      mov dx, 0x1f0$/;"	d
mov	boot/loader.S	/^      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,/;"	d
mov	boot/loader.S	/^      mov dx,0x1f2$/;"	d
mov	boot/loader.S	/^      mov dx,0x1f3                       $/;"	d
mov	boot/loader.S	/^      mov dx,0x1f4$/;"	d
mov	boot/loader.S	/^      mov dx,0x1f5$/;"	d
mov	boot/loader.S	/^      mov dx,0x1f6$/;"	d
mov	boot/loader.S	/^      mov dx,0x1f7$/;"	d
mov	boot/loader.S	/^   mov di, ards_buf	      ;ards结构缓冲区$/;"	d
mov	boot/loader.S	/^   mov ds, ax$/;"	d
mov	boot/loader.S	/^   mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  ; 偏移文件42字节处的属性是e_phentsize,表示/;"	d
mov	boot/mbr.S	/^      mov di,cx		  ;备份cx$/;"	d
mov	boot/mbr.S	/^      mov dx, 0x1f0$/;"	d
mov	boot/mbr.S	/^      mov dx, 256$/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f2$/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f3                       $/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f4$/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f5$/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f6$/;"	d
mov	boot/mbr.S	/^      mov dx,0x1f7$/;"	d
mov	boot/mbr.S	/^   mov     dx, 184fh		   ; 右下角: (80,25),$/;"	d
mov	boot/mbr.S	/^   mov ds,ax$/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d4			  ;索引寄存器$/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d4  ;索引寄存器$/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d4$/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d5			  ;通过读写数据端口0x3d5来获得或设置光标位置 $/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置 $/;"	d
mov	lib/kernel/print.S	/^   mov dx, 0x03d5 $/;"	d
mtime_sleep	device/timer.c	/^void mtime_sleep(uint32_t m_seconds) {$/;"	f	typeref:typename:void
mul	boot/loader.S	/^      mul dx$/;"	d
mul	boot/mbr.S	/^      mul dx$/;"	d
my_channel	device/ide.h	/^   struct ide_channel* my_channel;	   \/\/ 此块硬盘归属于哪个ide通道$/;"	m	struct:disk	typeref:struct:ide_channel *
my_disk	device/ide.h	/^   struct disk* my_disk;	 \/\/ 分区所属的硬盘$/;"	m	struct:partition	typeref:struct:disk *
my_shell	shell/shell.c	/^void my_shell(void) {$/;"	f	typeref:typename:void
name	device/ide.h	/^   char name[8];			   \/\/ 本硬盘的名称，如sda等$/;"	m	struct:disk	typeref:typename:char[8]
name	device/ide.h	/^   char name[8];		 \/\/ 分区名称$/;"	m	struct:partition	typeref:typename:char[8]
name	device/ide.h	/^   char name[8];		 \/\/ 本ata通道名称, 如ata0,也被叫做ide0. 可以参考bochs配置文/;"	m	struct:ide_channel	typeref:typename:char[8]
name	thread/thread.h	/^   char name[TASK_NAME_LEN];$/;"	m	struct:task_struct	typeref:typename:char[]
next	lib/kernel/list.h	/^   struct list_elem* next; \/\/ 后继结点$/;"	m	struct:list_elem	typeref:struct:list_elem *
next_ards	boot/loader.S	/^.next_ards:$/;"	l
next_pos	device/ioqueue.c	/^static int32_t next_pos(int32_t pos) {$/;"	f	typeref:typename:int32_t	file:
not_ready	boot/loader.S	/^  .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位$/;"	l
not_ready	boot/mbr.S	/^  .not_ready:$/;"	l
off_size	fs/inode.c	/^   uint32_t off_size;	\/\/ inode在扇区内的字节偏移量$/;"	m	struct:inode_position	typeref:typename:uint32_t	file:
offset	lib/kernel/list.h	/^#define offset(/;"	d
oflags	fs/fs.h	/^enum oflags {$/;"	g
open	lib/user/syscall.c	/^int32_t open(char* pathname, uint8_t flag) {$/;"	f	typeref:typename:int32_t
open_inodes	device/ide.h	/^   struct list open_inodes;	 \/\/ 本分区打开的i结点队列$/;"	m	struct:partition	typeref:struct:list
open_root_dir	fs/dir.c	/^void open_root_dir(struct partition* part) {$/;"	f	typeref:typename:void
opendir	lib/user/syscall.c	/^struct dir* opendir(const char* name) {$/;"	f	typeref:struct:dir *
other	device/ide.c	/^    uint8_t  other[446];		 \/\/ 引导代码$/;"	m	struct:boot_sector	typeref:typename:uint8_t[446]	file:
out	boot/loader.S	/^      out dx,al                          $/;"	d
out	boot/loader.S	/^      out dx,al            ;读取的扇区数$/;"	d
out	boot/loader.S	/^      out dx,al$/;"	d
out	boot/mbr.S	/^      out dx,al                          $/;"	d
out	boot/mbr.S	/^      out dx,al            ;读取的扇区数$/;"	d
out	boot/mbr.S	/^      out dx,al$/;"	d
out	lib/kernel/print.S	/^   out dx, al$/;"	d
outb	lib/kernel/io.h	/^static inline void outb(uint16_t port, uint8_t data) {$/;"	f	typeref:typename:void
outsw	lib/kernel/io.h	/^static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {$/;"	f	typeref:typename:void
p_align	userprog/exec.c	/^   Elf32_Word p_align;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Word	file:
p_filesz	userprog/exec.c	/^   Elf32_Word p_filesz;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Word	file:
p_flags	userprog/exec.c	/^   Elf32_Word p_flags;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Word	file:
p_memsz	userprog/exec.c	/^   Elf32_Word p_memsz;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Word	file:
p_mode_start	boot/loader.S	/^p_mode_start:$/;"	l
p_no	device/ide.c	/^uint8_t p_no = 0, l_no = 0;	 \/\/ 用来记录硬盘主分区和逻辑分区的下标$/;"	v	typeref:typename:uint8_t
p_offset	userprog/exec.c	/^   Elf32_Off  p_offset;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Off	file:
p_paddr	userprog/exec.c	/^   Elf32_Addr p_paddr;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Addr	file:
p_type	userprog/exec.c	/^   Elf32_Word p_type;		 \/\/ 见下面的enum segment_type$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Word	file:
p_vaddr	userprog/exec.c	/^   Elf32_Addr p_vaddr;$/;"	m	struct:Elf32_Phdr	typeref:typename:Elf32_Addr	file:
pad	fs/super_block.h	/^   uint8_t  pad[460];		    \/\/ 加上460字节,凑够512字节1扇区大小$/;"	m	struct:super_block	typeref:typename:uint8_t[460]
pad_print	thread/thread.c	/^static void pad_print(char* buf, int32_t buf_len, void* ptr, char format) {$/;"	f	typeref:typename:void	file:
page_dir_activate	userprog/process.c	/^void page_dir_activate(struct task_struct* p_thread) {$/;"	f	typeref:typename:void
page_table_add	kernel/memory.c	/^static void page_table_add(void* _vaddr, void* _page_phyaddr) {$/;"	f	typeref:typename:void	file:
page_table_pte_remove	kernel/memory.c	/^static void page_table_pte_remove(uint32_t vaddr) {$/;"	f	typeref:typename:void	file:
palloc	kernel/memory.c	/^static void* palloc(struct pool* m_pool) {$/;"	f	typeref:typename:void *	file:
panic	lib/user/assert.h	/^#define panic(/;"	d
panic_spin	kernel/debug.c	/^void panic_spin(char* filename,	       \\$/;"	f	typeref:typename:void
parent_dir	fs/fs.h	/^   struct dir* parent_dir;		    \/\/ 文件或目录所在的直接父目录$/;"	m	struct:path_search_record	typeref:struct:dir *
parent_pid	thread/thread.h	/^   pid_t parent_pid;		 \/\/ 父进程pid$/;"	m	struct:task_struct	typeref:typename:pid_t
part_lba_base	fs/super_block.h	/^   uint32_t part_lba_base;	    \/\/ 本分区的起始lba地址$/;"	m	struct:super_block	typeref:typename:uint32_t
part_tag	device/ide.h	/^   struct list_elem part_tag;	 \/\/ 用于队列中的标记$/;"	m	struct:partition	typeref:struct:list_elem
partition	device/ide.h	/^struct partition {$/;"	s
partition_format	fs/fs.c	/^static void partition_format(struct partition* part) {$/;"	f	typeref:typename:void	file:
partition_info	device/ide.c	/^static bool partition_info(struct list_elem* pelem, int arg UNUSED) {$/;"	f	typeref:typename:bool	file:
partition_list	device/ide.c	/^struct list partition_list;	 \/\/ 分区队列$/;"	v	typeref:struct:list
partition_scan	device/ide.c	/^static void partition_scan(struct disk* hd, uint32_t ext_lba) {$/;"	f	typeref:typename:void	file:
partition_table	device/ide.c	/^    struct   partition_table_entry partition_table[4];       \/\/ 分区表中有4项,共64字节$/;"	m	struct:boot_sector	typeref:struct:partition_table_entry[4]	file:
partition_table_entry	device/ide.c	/^struct partition_table_entry {$/;"	s	file:
path_depth_cnt	fs/fs.c	/^int32_t path_depth_cnt(char* pathname) {$/;"	f	typeref:typename:int32_t
path_parse	fs/fs.c	/^char* path_parse(char* pathname, char* name_store) {$/;"	f	typeref:typename:char *
path_search_record	fs/fs.h	/^struct path_search_record {$/;"	s
pcb_fd_install	fs/file.c	/^int32_t pcb_fd_install(int32_t globa_fd_idx) {$/;"	f	typeref:typename:int32_t
pde_ptr	kernel/memory.c	/^uint32_t* pde_ptr(uint32_t vaddr) {$/;"	f	typeref:typename:uint32_t *
pfree	kernel/memory.c	/^void pfree(uint32_t pg_phy_addr) {$/;"	f	typeref:typename:void
pgdir	thread/thread.h	/^   uint32_t* pgdir;              \/\/ 进程自己页表的虚拟地址$/;"	m	struct:task_struct	typeref:typename:uint32_t *
phy_addr_start	kernel/memory.c	/^   uint32_t phy_addr_start;	 \/\/ 本内存池所管理物理内存的起始地址$/;"	m	struct:pool	typeref:typename:uint32_t	file:
pic_init	kernel/interrupt.c	/^static void pic_init(void) {$/;"	f	typeref:typename:void	file:
pid	thread/thread.h	/^   pid_t pid;$/;"	m	struct:task_struct	typeref:typename:pid_t
pid2thread	thread/thread.c	/^struct task_struct* pid2thread(int32_t pid) {$/;"	f	typeref:struct:task_struct *
pid_bitmap	thread/thread.c	/^   struct bitmap pid_bitmap;  \/\/ pid位图$/;"	m	struct:pid_pool	typeref:struct:bitmap	file:
pid_bitmap_bits	thread/thread.c	/^uint8_t pid_bitmap_bits[128] = {0};$/;"	v	typeref:typename:uint8_t[128]
pid_check	thread/thread.c	/^static bool pid_check(struct list_elem* pelem, int32_t pid) {$/;"	f	typeref:typename:bool	file:
pid_lock	thread/thread.c	/^   struct lock pid_lock;      \/\/ 分配pid锁$/;"	m	struct:pid_pool	typeref:struct:lock	file:
pid_pool	thread/thread.c	/^struct pid_pool {$/;"	s	file:
pid_pool	thread/thread.c	/^}pid_pool;$/;"	v	typeref:struct:pid_pool
pid_pool_init	thread/thread.c	/^static void pid_pool_init(void) { $/;"	f	typeref:typename:void	file:
pid_start	thread/thread.c	/^   uint32_t pid_start;	      \/\/ 起始pid$/;"	m	struct:pid_pool	typeref:typename:uint32_t	file:
pid_t	thread/thread.h	/^typedef int16_t pid_t;$/;"	t	typeref:typename:int16_t
pipe	lib/user/syscall.c	/^int32_t pipe(int32_t pipefd[2]) {$/;"	f	typeref:typename:int32_t
pipe_read	shell/pipe.c	/^uint32_t pipe_read(int32_t fd, void* buf, uint32_t count) {$/;"	f	typeref:typename:uint32_t
pipe_write	shell/pipe.c	/^uint32_t pipe_write(int32_t fd, const void* buf, uint32_t count) {$/;"	f	typeref:typename:uint32_t
pool	kernel/memory.c	/^struct pool {$/;"	s	file:
pool_bitmap	kernel/memory.c	/^   struct bitmap pool_bitmap;	 \/\/ 本内存池用到的位图结构,用于管理物理内存$/;"	m	struct:pool	typeref:struct:bitmap	file:
pool_flags	kernel/memory.h	/^enum pool_flags {$/;"	g
pool_size	kernel/memory.c	/^   uint32_t pool_size;		 \/\/ 本内存池字节容量$/;"	m	struct:pool	typeref:typename:uint32_t	file:
pop	kernel/kernel.S	/^   pop ds$/;"	d
pop	kernel/kernel.asm	/^ pop ds$/;"	d
port_base	device/ide.h	/^   uint16_t port_base;		 \/\/ 本通道的起始端口号$/;"	m	struct:ide_channel	typeref:typename:uint16_t
prev	lib/kernel/list.h	/^   struct list_elem* prev; \/\/ 前躯结点$/;"	m	struct:list_elem	typeref:struct:list_elem *
prim_parts	device/ide.h	/^   struct partition prim_parts[4];	   \/\/ 主分区顶多是4个$/;"	m	struct:disk	typeref:struct:partition[4]
print_prompt	shell/shell.c	/^void print_prompt(void) {$/;"	f	typeref:typename:void
printf	lib/stdio.c	/^uint32_t printf(const char* format, ...) {$/;"	f	typeref:typename:uint32_t
printk	lib/kernel/stdio-kernel.c	/^void printk(const char* format, ...) {$/;"	f	typeref:typename:void
priority	thread/thread.h	/^   uint8_t priority;$/;"	m	struct:task_struct	typeref:typename:uint8_t
process_activate	userprog/process.c	/^void process_activate(struct task_struct* p_thread) {$/;"	f	typeref:typename:void
process_execute	userprog/process.c	/^void process_execute(void* filename, char* name) { $/;"	f	typeref:typename:void
producer	device/ioqueue.h	/^    struct task_struct* producer;$/;"	m	struct:ioqueue	typeref:struct:task_struct *
ps	lib/user/syscall.c	/^void ps(void) {$/;"	f	typeref:typename:void
pte_ptr	kernel/memory.c	/^uint32_t* pte_ptr(uint32_t vaddr) {$/;"	f	typeref:typename:uint32_t *
push	kernel/kernel.S	/^   push ds$/;"	d
push	kernel/kernel.asm	/^ push ds$/;"	d
put_char	lib/kernel/print.S	/^put_char:$/;"	l
put_char_done	lib/kernel/print.S	/^ .put_char_done: $/;"	l
put_each_num	lib/kernel/print.S	/^.put_each_num:$/;"	l
put_int	lib/kernel/print.S	/^put_int:$/;"	l
put_int_buffer	lib/kernel/print.S	/^put_int_buffer    dq    0     ; 定义8字节缓冲区用于数字到字符的转换$/;"	d
put_other	lib/kernel/print.S	/^ .put_other:$/;"	l
put_str	lib/kernel/print.S	/^put_str:$/;"	l
putchar	lib/user/syscall.c	/^void putchar(char char_asci) {$/;"	f	typeref:typename:void
rd_disk_m_16	boot/mbr.S	/^rd_disk_m_16:	   $/;"	l
rd_disk_m_32	boot/loader.S	/^rd_disk_m_32:	   $/;"	l
read	lib/user/syscall.c	/^int32_t read(int32_t fd, void* buf, uint32_t count) {$/;"	f	typeref:typename:int32_t
read_from_sector	device/ide.c	/^static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {$/;"	f	typeref:typename:void	file:
readdir	lib/user/syscall.c	/^struct dir_entry* readdir(struct dir* dir) {$/;"	f	typeref:struct:dir_entry *
readline	shell/shell.c	/^static void readline(char* buf, int32_t count) {$/;"	f	typeref:typename:void	file:
ready_to_print	lib/kernel/print.S	/^.ready_to_print:$/;"	l
reg_alt_status	device/ide.c	/^#define reg_alt_status(/;"	d	file:
reg_cmd	device/ide.c	/^#define reg_cmd(/;"	d	file:
reg_ctl	device/ide.c	/^#define reg_ctl(/;"	d	file:
reg_data	device/ide.c	/^#define reg_data(/;"	d	file:
reg_dev	device/ide.c	/^#define reg_dev(/;"	d	file:
reg_error	device/ide.c	/^#define reg_error(/;"	d	file:
reg_lba_h	device/ide.c	/^#define reg_lba_h(/;"	d	file:
reg_lba_l	device/ide.c	/^#define reg_lba_l(/;"	d	file:
reg_lba_m	device/ide.c	/^#define reg_lba_m(/;"	d	file:
reg_sect_cnt	device/ide.c	/^#define reg_sect_cnt(/;"	d	file:
reg_status	device/ide.c	/^#define reg_status(/;"	d	file:
register_handler	kernel/interrupt.c	/^void register_handler(uint8_t vector_no, intr_handler function) {$/;"	f	typeref:typename:void
release_pid	thread/thread.c	/^void release_pid(pid_t pid) {$/;"	f	typeref:typename:void
release_prog_resource	userprog/wait_exit.c	/^static void release_prog_resource(struct task_struct* release_thread) {$/;"	f	typeref:typename:void	file:
rewinddir	lib/user/syscall.c	/^void rewinddir(struct dir* dir) {$/;"	f	typeref:typename:void
rmdir	lib/user/syscall.c	/^int32_t rmdir(const char* pathname) {$/;"	f	typeref:typename:int32_t
roll_screen	lib/kernel/print.S	/^ .roll_screen:				  ; 若超出屏幕大小，开始滚屏$/;"	l
root_dir	fs/dir.c	/^struct dir root_dir;             \/\/ 根目录$/;"	v	typeref:struct:dir
root_inode_no	fs/super_block.h	/^   uint32_t root_inode_no;	    \/\/ 根目录所在的I结点号$/;"	m	struct:super_block	typeref:typename:uint32_t
running_thread	thread/thread.c	/^struct task_struct* running_thread() {$/;"	f	typeref:struct:task_struct *
sb	device/ide.h	/^   struct super_block* sb;	 \/\/ 本分区的超级块$/;"	m	struct:partition	typeref:struct:super_block *
schedule	thread/thread.c	/^void schedule() {$/;"	f	typeref:typename:void
search_dir_entry	fs/dir.c	/^bool search_dir_entry(struct partition* part, struct dir* pdir, \\$/;"	f	typeref:typename:bool
search_file	fs/fs.c	/^static int search_file(const char* pathname, struct path_search_record* searched_record) {$/;"	f	typeref:typename:int	file:
searched_path	fs/fs.h	/^   char searched_path[MAX_PATH_LEN];	    \/\/ 查找过程中的父路径$/;"	m	struct:path_search_record	typeref:typename:char[]
sec_cnt	device/ide.c	/^    uint32_t sec_cnt;		 \/\/ 本分区的扇区数目$/;"	m	struct:partition_table_entry	typeref:typename:uint32_t	file:
sec_cnt	device/ide.h	/^   uint32_t sec_cnt;		 \/\/ 扇区数$/;"	m	struct:partition	typeref:typename:uint32_t
sec_cnt	fs/super_block.h	/^   uint32_t sec_cnt;		    \/\/ 本分区总共的扇区数$/;"	m	struct:super_block	typeref:typename:uint32_t
sec_lba	fs/inode.c	/^   uint32_t sec_lba;	\/\/ inode所在的扇区号$/;"	m	struct:inode_position	typeref:typename:uint32_t	file:
segment_load	userprog/exec.c	/^static bool segment_load(int32_t fd, uint32_t offset, uint32_t filesz, uint32_t vaddr) {$/;"	f	typeref:typename:bool	file:
segment_type	userprog/exec.c	/^enum segment_type {$/;"	g	file:
select_disk	device/ide.c	/^static void select_disk(struct disk* hd) {$/;"	f	typeref:typename:void	file:
select_sector	device/ide.c	/^static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {$/;"	f	typeref:typename:void	file:
selector	kernel/interrupt.c	/^   uint16_t    selector;$/;"	m	struct:gate_desc	typeref:typename:uint16_t	file:
self_kstack	thread/thread.h	/^   uint32_t* self_kstack;	 \/\/ 各内核线程都用自己的内核栈$/;"	m	struct:task_struct	typeref:typename:uint32_t *
sema_down	thread/sync.c	/^void sema_down(struct semaphore* psema) {$/;"	f	typeref:typename:void
sema_init	thread/sync.c	/^void sema_init(struct semaphore* psema, uint8_t value) {$/;"	f	typeref:typename:void
sema_up	thread/sync.c	/^void sema_up(struct semaphore* psema) {$/;"	f	typeref:typename:void
semaphore	thread/sync.h	/^   struct   semaphore semaphore;	    \/\/ 用二元信号量实现锁$/;"	m	struct:lock	typeref:struct:semaphore
semaphore	thread/sync.h	/^struct semaphore {$/;"	s
set_cursor	lib/kernel/print.S	/^ .set_cursor:				  ;直接把set_cursor搬过来用,省事$/;"	l
set_cursor	lib/kernel/print.S	/^ .set_cursor:   $/;"	l
set_cursor	lib/kernel/print.S	/^set_cursor:$/;"	l
setup_page	boot/loader.S	/^setup_page:$/;"	l
shift_l_char	device/keyboard.c	/^#define shift_l_char	/;"	d	file:
shift_l_make	device/keyboard.c	/^#define shift_l_make	/;"	d	file:
shift_r_char	device/keyboard.c	/^#define shift_r_char	/;"	d	file:
shift_r_make	device/keyboard.c	/^#define shift_r_make /;"	d	file:
shift_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	typeref:typename:bool	file:
signature	device/ide.c	/^    uint16_t signature;		 \/\/ 启动扇区的结束标志是0x55,0xaa,$/;"	m	struct:boot_sector	typeref:typename:uint16_t	file:
skip_prefix_0	lib/kernel/print.S	/^.skip_prefix_0:  $/;"	l
sprintf	lib/stdio.c	/^uint32_t sprintf(char* buf, const char* format, ...) {$/;"	f	typeref:typename:uint32_t
ss	thread/thread.h	/^    uint32_t ss;$/;"	m	struct:intr_stack	typeref:typename:uint32_t
ss	userprog/tss.c	/^    uint32_t ss;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ss0	userprog/tss.c	/^    uint32_t ss0;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ss1	userprog/tss.c	/^    uint32_t ss1;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
ss2	userprog/tss.c	/^    uint32_t ss2;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
st_filetype	fs/fs.h	/^   enum file_types st_filetype;	 \/\/ 文件类型$/;"	m	struct:stat	typeref:enum:file_types
st_ino	fs/fs.h	/^   uint32_t st_ino;		 \/\/ inode编号$/;"	m	struct:stat	typeref:typename:uint32_t
st_size	fs/fs.h	/^   uint32_t st_size;		 \/\/ 尺寸$/;"	m	struct:stat	typeref:typename:uint32_t
stack_magic	thread/thread.h	/^   uint32_t stack_magic;	 \/\/ 用这串数字做栈的边界标记,用于检测栈的溢出$/;"	m	struct:task_struct	typeref:typename:uint32_t
start_chs	device/ide.c	/^    uint8_t  start_chs;		 \/\/ 起始柱面号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
start_head	device/ide.c	/^    uint8_t  start_head;		 \/\/ 起始磁头号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
start_lba	device/ide.c	/^    uint32_t start_lba;		 \/\/ 本分区起始扇区的lba地址$/;"	m	struct:partition_table_entry	typeref:typename:uint32_t	file:
start_lba	device/ide.h	/^   uint32_t start_lba;		 \/\/ 起始扇区$/;"	m	struct:partition	typeref:typename:uint32_t
start_process	userprog/process.c	/^void start_process(void* filename_) {$/;"	f	typeref:typename:void
start_sec	device/ide.c	/^    uint8_t  start_sec;		 \/\/ 起始扇区号$/;"	m	struct:partition_table_entry	typeref:typename:uint8_t	file:
stat	fs/fs.h	/^struct stat {$/;"	s
stat	lib/user/syscall.c	/^int32_t stat(const char* path, struct stat* buf) {$/;"	f	typeref:typename:int32_t
status	thread/thread.h	/^   enum task_status status;$/;"	m	struct:task_struct	typeref:enum:task_status
std_fd	fs/file.h	/^enum std_fd {$/;"	g
stderr_no	fs/file.h	/^   stderr_no   \/\/ 2 标准错误$/;"	e	enum:std_fd
stdin_no	fs/file.h	/^   stdin_no,   \/\/ 0 标准输入$/;"	e	enum:std_fd
stdout_no	fs/file.h	/^   stdout_no,  \/\/ 1 标准输出$/;"	e	enum:std_fd
store	lib/kernel/print.S	/^.store:$/;"	l
str_over	lib/kernel/print.S	/^.str_over:$/;"	l
strcat	lib/string.c	/^char* strcat(char* dst_, const char* src_) {$/;"	f	typeref:typename:char *
strchr	lib/string.c	/^char* strchr(const char* str, const uint8_t ch) {$/;"	f	typeref:typename:char *
strchrs	lib/string.c	/^uint32_t strchrs(const char* str, uint8_t ch) {$/;"	f	typeref:typename:uint32_t
strcmp	lib/string.c	/^int8_t strcmp (const char* a, const char* b) {$/;"	f	typeref:typename:int8_t
strcpy	lib/string.c	/^char* strcpy(char* dst_, const char* src_) {$/;"	f	typeref:typename:char *
strlen	lib/string.c	/^uint32_t strlen(const char* str) {$/;"	f	typeref:typename:uint32_t
strrchr	lib/string.c	/^char* strrchr(const char* str, const uint8_t ch) {$/;"	f	typeref:typename:char *
super_block	fs/super_block.h	/^struct super_block {$/;"	s
swap_pairs_bytes	device/ide.c	/^static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {$/;"	f	typeref:typename:void	file:
switch_to	thread/switch.S	/^switch_to:$/;"	l
sync_dir_entry	fs/dir.c	/^bool sync_dir_entry(struct dir* parent_dir, struct dir_entry* p_de, void* io_buf) {$/;"	f	typeref:typename:bool
sys_chdir	fs/fs.c	/^int32_t sys_chdir(const char* path) {$/;"	f	typeref:typename:int32_t
sys_close	fs/fs.c	/^int32_t sys_close(int32_t fd) {$/;"	f	typeref:typename:int32_t
sys_closedir	fs/fs.c	/^int32_t sys_closedir(struct dir* dir) {$/;"	f	typeref:typename:int32_t
sys_execv	userprog/exec.c	/^int32_t sys_execv(const char* path, const char* argv[]) {$/;"	f	typeref:typename:int32_t
sys_exit	userprog/wait_exit.c	/^void sys_exit(int32_t status) {$/;"	f	typeref:typename:void
sys_fd_redirect	shell/pipe.c	/^void sys_fd_redirect(uint32_t old_local_fd, uint32_t new_local_fd) {$/;"	f	typeref:typename:void
sys_fork	userprog/fork.c	/^pid_t sys_fork(void) {$/;"	f	typeref:typename:pid_t
sys_free	kernel/memory.c	/^void sys_free(void* ptr) {$/;"	f	typeref:typename:void
sys_getcwd	fs/fs.c	/^char* sys_getcwd(char* buf, uint32_t size) {$/;"	f	typeref:typename:char *
sys_getpid	userprog/syscall-init.c	/^uint32_t sys_getpid(void) {$/;"	f	typeref:typename:uint32_t
sys_help	fs/fs.c	/^void sys_help(void) {$/;"	f	typeref:typename:void
sys_lseek	fs/fs.c	/^int32_t sys_lseek(int32_t fd, int32_t offset, uint8_t whence) {$/;"	f	typeref:typename:int32_t
sys_malloc	kernel/memory.c	/^void* sys_malloc(uint32_t size) {$/;"	f	typeref:typename:void *
sys_mkdir	fs/fs.c	/^int32_t sys_mkdir(const char* pathname) {$/;"	f	typeref:typename:int32_t
sys_open	fs/fs.c	/^int32_t sys_open(const char* pathname, uint8_t flags) {$/;"	f	typeref:typename:int32_t
sys_opendir	fs/fs.c	/^struct dir* sys_opendir(const char* name) {$/;"	f	typeref:struct:dir *
sys_pipe	shell/pipe.c	/^int32_t sys_pipe(int32_t pipefd[2]) {$/;"	f	typeref:typename:int32_t
sys_ps	thread/thread.c	/^void sys_ps(void) {$/;"	f	typeref:typename:void
sys_putchar	fs/fs.c	/^void sys_putchar(char char_asci) {$/;"	f	typeref:typename:void
sys_read	fs/fs.c	/^int32_t sys_read(int32_t fd, void* buf, uint32_t count) {$/;"	f	typeref:typename:int32_t
sys_readdir	fs/fs.c	/^struct dir_entry* sys_readdir(struct dir* dir) {$/;"	f	typeref:struct:dir_entry *
sys_rewinddir	fs/fs.c	/^void sys_rewinddir(struct dir* dir) {$/;"	f	typeref:typename:void
sys_rmdir	fs/fs.c	/^int32_t sys_rmdir(const char* pathname) {$/;"	f	typeref:typename:int32_t
sys_stat	fs/fs.c	/^int32_t sys_stat(const char* path, struct stat* buf) {$/;"	f	typeref:typename:int32_t
sys_unlink	fs/fs.c	/^int32_t sys_unlink(const char* pathname) {$/;"	f	typeref:typename:int32_t
sys_wait	userprog/wait_exit.c	/^pid_t sys_wait(int32_t* status) {$/;"	f	typeref:typename:pid_t
sys_write	fs/fs.c	/^int32_t sys_write(int32_t fd, const void* buf, uint32_t count) {$/;"	f	typeref:typename:int32_t
syscall	userprog/syscall-init.c	/^typedef void* syscall;$/;"	t	typeref:typename:void *	file:
syscall_handler	kernel/kernel.S	/^syscall_handler:$/;"	l
syscall_handler	kernel/kernel.asm	/^syscall_handler:$/;"	l
syscall_init	userprog/syscall-init.c	/^void syscall_init(void) {$/;"	f	typeref:typename:void
syscall_nr	userprog/syscall-init.c	/^#define syscall_nr /;"	d	file:
syscall_table	userprog/syscall-init.c	/^syscall syscall_table[syscall_nr];$/;"	v	typeref:typename:syscall[]
tab	device/keyboard.c	/^#define tab	/;"	d	file:
tail	device/ioqueue.h	/^    int32_t tail;			    \/\/ 队尾,数据从队尾处读出$/;"	m	struct:ioqueue	typeref:typename:int32_t
tail	lib/kernel/list.h	/^   struct list_elem tail;$/;"	m	struct:list	typeref:struct:list_elem
task_status	thread/thread.h	/^enum task_status {$/;"	g
task_struct	thread/thread.h	/^struct task_struct {$/;"	s
thread_all_list	thread/thread.c	/^struct list thread_all_list;	    \/\/ 所有任务队列$/;"	v	typeref:struct:list
thread_block	thread/thread.c	/^void thread_block(enum task_status stat) {$/;"	f	typeref:typename:void
thread_create	thread/thread.c	/^void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {$/;"	f	typeref:typename:void
thread_exit	thread/thread.c	/^void thread_exit(struct task_struct* thread_over, bool need_schedule) {$/;"	f	typeref:typename:void
thread_func	thread/thread.h	/^typedef void thread_func(void*);$/;"	t	typeref:typename:void ()(void *)
thread_init	thread/thread.c	/^void thread_init(void) {$/;"	f	typeref:typename:void
thread_ready_list	thread/thread.c	/^struct list thread_ready_list;	    \/\/ 就绪队列$/;"	v	typeref:struct:list
thread_stack	thread/thread.h	/^struct thread_stack {$/;"	s
thread_start	thread/thread.c	/^struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {$/;"	f	typeref:struct:task_struct *
thread_tag	thread/thread.c	/^static struct list_elem* thread_tag;\/\/ 用于保存队列中的线程结点$/;"	v	typeref:struct:list_elem *	file:
thread_unblock	thread/thread.c	/^void thread_unblock(struct task_struct* pthread) {$/;"	f	typeref:typename:void
thread_yield	thread/thread.c	/^void thread_yield(void) {$/;"	f	typeref:typename:void
ticks	device/timer.c	/^uint32_t ticks;          \/\/ ticks是内核自中断开启以来总共的嘀嗒数$/;"	v	typeref:typename:uint32_t
ticks	thread/thread.h	/^   uint8_t ticks;	   \/\/ 每次在处理器上执行的时间嘀嗒数$/;"	m	struct:task_struct	typeref:typename:uint8_t
ticks_to_sleep	device/timer.c	/^static void ticks_to_sleep(uint32_t sleep_ticks) {$/;"	f	typeref:typename:void	file:
timer_init	device/timer.c	/^void timer_init() {$/;"	f	typeref:typename:void
total_mem_bytes	boot/loader.S	/^   total_mem_bytes dd 0					 $/;"	d
trace	userprog/tss.c	/^    uint32_t trace;$/;"	m	struct:tss	typeref:typename:uint32_t	file:
true	kernel/global.h	/^#define true /;"	d
tss	userprog/tss.c	/^static struct tss tss;$/;"	v	typeref:struct:tss	file:
tss	userprog/tss.c	/^struct tss {$/;"	s	file:
tss_init	userprog/tss.c	/^void tss_init() {$/;"	f	typeref:typename:void
two_sec	fs/inode.c	/^   bool	 two_sec;	\/\/ inode是否跨扇区$/;"	m	struct:inode_position	typeref:typename:bool	file:
u_block_desc	thread/thread.h	/^   struct mem_block_desc u_block_desc[DESC_CNT];   \/\/ 用户进程内存块描述符$/;"	m	struct:task_struct	typeref:struct:mem_block_desc[]
uint16_t	lib/stdint.h	/^typedef unsigned short int uint16_t;$/;"	t	typeref:typename:unsigned short int
uint32_t	lib/stdint.h	/^typedef unsigned int uint32_t;$/;"	t	typeref:typename:unsigned int
uint64_t	lib/stdint.h	/^typedef unsigned long long int uint64_t;$/;"	t	typeref:typename:unsigned long long int
uint8_t	lib/stdint.h	/^typedef unsigned char uint8_t;$/;"	t	typeref:typename:unsigned char
unlink	lib/user/syscall.c	/^int32_t unlink(const char* pathname) {$/;"	f	typeref:typename:int32_t
unused_retaddr	thread/thread.h	/^   void (*unused_retaddr);$/;"	m	struct:thread_stack	typeref:typename:void (*)
update_inode_open_cnts	userprog/fork.c	/^static void update_inode_open_cnts(struct task_struct* thread) {$/;"	f	typeref:typename:void	file:
update_tss_esp	userprog/tss.c	/^void update_tss_esp(struct task_struct* pthread) {$/;"	f	typeref:typename:void
user_pool	kernel/memory.c	/^struct pool kernel_pool, user_pool;      \/\/ 生成内核内存池和用户内存池$/;"	v	typeref:struct:pool
user_spin	lib/user/assert.c	/^void user_spin(char* filename, int line, const char* func, const char* condition) {$/;"	f	typeref:typename:void
userprog_vaddr	thread/thread.h	/^   struct virtual_addr userprog_vaddr;   \/\/ 用户进程的虚拟地址$/;"	m	struct:task_struct	typeref:struct:virtual_addr
va_arg	lib/stdio.c	/^#define va_arg(/;"	d	file:
va_end	lib/kernel/stdio-kernel.c	/^#define va_end(/;"	d	file:
va_end	lib/stdio.c	/^#define va_end(/;"	d	file:
va_list	lib/stdio.h	/^typedef char* va_list;$/;"	t	typeref:typename:char *
va_start	lib/kernel/stdio-kernel.c	/^#define va_start(/;"	d	file:
va_start	lib/stdio.c	/^#define va_start(/;"	d	file:
vaddr_bitmap	kernel/memory.h	/^   struct bitmap vaddr_bitmap;$/;"	m	struct:virtual_addr	typeref:struct:bitmap
vaddr_get	kernel/memory.c	/^static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {$/;"	f	typeref:typename:void *	file:
vaddr_remove	kernel/memory.c	/^static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {$/;"	f	typeref:typename:void	file:
vaddr_start	kernel/memory.h	/^   uint32_t vaddr_start;$/;"	m	struct:virtual_addr	typeref:typename:uint32_t
value	thread/sync.h	/^   uint8_t  value;$/;"	m	struct:semaphore	typeref:typename:uint8_t
vec_no	thread/thread.h	/^    uint32_t vec_no;	 \/\/ kernel.S 宏VECTOR中push %1压入的中断号$/;"	m	struct:intr_stack	typeref:typename:uint32_t
virtual_addr	kernel/memory.h	/^struct virtual_addr {$/;"	s
vsprintf	lib/stdio.c	/^uint32_t vsprintf(char* str, const char* format, va_list ap) {$/;"	f	typeref:typename:uint32_t
wait	lib/user/syscall.c	/^pid_t wait(int32_t* status) {$/;"	f	typeref:typename:pid_t
waiters	thread/sync.h	/^   struct   list waiters;$/;"	m	struct:semaphore	typeref:struct:list
wakeup	device/ioqueue.c	/^static void wakeup(struct task_struct** waiter) {$/;"	f	typeref:typename:void	file:
wash_path	shell/buildin_cmd.c	/^static void wash_path(char* old_abs_path, char* new_abs_path) {$/;"	f	typeref:typename:void	file:
whence	fs/fs.h	/^enum whence {$/;"	g
write	lib/user/syscall.c	/^uint32_t write(int32_t fd, const void* buf, uint32_t count) {$/;"	f	typeref:typename:uint32_t
write2sector	device/ide.c	/^static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {$/;"	f	typeref:typename:void	file:
write_deny	fs/inode.h	/^   bool write_deny;	   \/\/ 写文件不能并行,进程写文件前检查此标识$/;"	m	struct:inode	typeref:typename:bool
xor	lib/kernel/print.S	/^   xor dx, dx				  ; dx是被除数的高16位,清0.$/;"	d
