10-03-pinctrl子系统框架分析

1 GPIO，pinctrl子系统简介和结构
1.1 GPIO子系统系统结构--参考图1
	通过GPIO子系统功能：
	引脚功能的配置（设置为GPIO，特殊功能，GPIO的方向，设置为中断等等）；
	实现软硬件的分离（分离出硬件差异，有厂商提供底层支持；软件分层，驱动只需要调用接口API即可操作GPIO）；
	iommu内存管理（直接调用宏即可操作GPIO）。
	
1.2 pinctrl子系统简介和结构--参考图2
	pinctrl子系统和GPIO子系统的结构和功能类似，内部结构有所差异
	
2 pinctrl子系统和GPIO子系统之间的关系--参考图3
	在引入设备树之后，GPIO子系统是通过pinctrl子系统来实现的，这一点要牢记。
	
3 pinctrl子系统内部结构--参考图4
	pinctrl的内部主要分为两部分功能：pin config管脚配置和pin mux管脚复用 
	驱动调用pin脚（不仅指GPIO，例如uart也需要用到pin脚），那么需要用到两部分硬件的功能：
	A: 设置引脚功能的复用；
	B：配置pin脚的状态。
	
	pinctrl子系统相比gpio子系统，增加了引脚复用和pin脚状态设置这两个功能。
	在以前驱动移植中，经常会遇到，调试很久的驱动，发现管脚的初始化出了问题（这是经常会遇到的问题）。
	传统模式中，管脚初始化在uboot中或者在内核中增加额外的初始化代码（不同的平台版本有区别），也有可能在驱动中额外增加初始化代码。
	
	pinctrl子系统引入了设置引脚功能复用和配置pin脚，这个功能需要和设备树文件结合使用。
	在驱动中，可以直接而通用的实现管脚功能复用和配置，这样驱动的移植工作会更加简单。
	
通过以上分析，引出了以下问题：
 pinctrl子系统引入之后，设备树的pinctrl分析和写；
 pinctrl子系统引入之后，设备树的pinctrl如何在驱动中实现初始化和配置；
 pinctrl子系统引入之后，gpio子系统驱动的变化。
 
 PS：由于设备树引入了pinctrl子系统，后续驱动移植工作量将大大降低。
 驱动为什么要移植，而不能直接使用？
 一方面是：上层应用接口的变化，不过这种情况很少;
 另外一方面：主要是因为硬件差异，现在更多的硬件管脚差异--pinctrl的初始化和配置放到了设备树中
 --（不仅仅是pin这部分硬件差异在设备树中），所以很多移植只需要修改下设备树文件即可。
