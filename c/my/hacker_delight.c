#include <stdio.h> 
#include <string.h>
/*
  下面列举了一些常见的二进制位的变换操作。

    功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))

答案：假设x为32位整数，则x xor (not (x shr 31) + 1) + x shr 31的结果是x的绝对值
x shr 31是二进制的最高位，它用来表示x的符号。如果它为0（x为正），则not (x shr 31) + 1等于$00000000，
异或任何数结果都不变；如果最高位为1（x为负），则not (x shr 31) + 1等于$FFFFFFFF，x异或它相当于所有数位取反，异或完后再加一。
*/

//位与操作
// void swap(int &a, int &b) {
//   a ^= b;
//   b ^= a;
//   a ^= b;
// }

// if(0 == (a & 1)) {
//  //偶数
// }
// 交换符号将正数变成负数，负数变成正数
// 整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数
int reversal(int a) {
  return ~a + 1;
}

// 5. 位操作求绝对值
// 整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，
// 即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作
 int abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
// 上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。
// 我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。
// 对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,
// 因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，
// 负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)

int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}

// 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值
// unsigned short a = 34520;
// a = (a >> 8) | (a << 8);

int main()
{
    int x = 0b110;
    printf("%x\t",x&(x-1));
    printf("%x\t",x&(x+1));
    printf("%x\t",x&(-x));
    printf("%x\t",~x&(x+1));
    printf("%x\t",~x&(x-1));
    printf("%x\t",~(x|-x));
    printf("%x\t",x&(-x) -1);
    printf("%x\t",x^(x-1));
    printf("%x\t",x|(x-1));
    printf("%x\t",(x|(x-1)+1)&x);
    printf("%x\t",(x|(x-1)+1)&x);
    return 0;
}