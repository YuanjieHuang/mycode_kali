// PriorityQueue.cpp -- function definitions for a Priority Queue implemented// with a linked (embedded) heap#include <iostream>using namespace std;template <class DataType>PriorityQueue<DataType>::PriorityQueue( ){    last = lastParent = root = &rootHeader;	root->next = NULL;	left = false;}template <class DataType>PriorityQueue<DataType>::PriorityQueue( Array<DataType> & arr ){    last = lastParent = root = &rootHeader;	left = false;    for ( int i = 0; i < arr.length( ); i++ ) 		insertNode( arr[ i ] );    for ( PQNode<DataType> *current = last->parent; current != root; current = current->back )        heapify( current );}template <class DataType>PriorityQueue<DataType>::PriorityQueue( const PriorityQueue<DataType> & appq ){	deepCopy( appq );}template <class DataType>PriorityQueue<DataType>::~PriorityQueue( ){	makeEmpty( );}template <class DataType>PriorityQueue<DataType> & PriorityQueue<DataType>::operator =( const PriorityQueue<DataType> & rpq ){	if ( this == &rpq )		return *this;	makeEmpty( );	deepCopy( rpq );	return *this;}template <class DataType>void PriorityQueue<DataType>::enqueue( const DataType & newElement){	insertNode( newElement );    // reheap upwards from the bottom    PQNode<DataType> *current = last, *parent = current->parent;    while ( parent != root && newElement > parent->info ) {        current->info = parent->info;        current = parent;		parent = current->parent;    }    current->info = newElement;}template <class DataType>bool PriorityQueue<DataType>::dequeue( DataType & deqElement ){	if ( root == last )		return false;    PQNode<DataType> *current = root->right;    deqElement = current->info;    current->info = last->info;    if (left) {        lastParent = lastParent->back;        lastParent->right = NULL;    }    else        lastParent->left = NULL;    last = last->back;	delete last->next;    last->next = NULL;    left = !left;	if ( root != last )		heapify( current );	return true;}template <class DataType>bool PriorityQueue<DataType>::isEmpty(){    return root == last;}template <class DataType>void PriorityQueue<DataType>::makeEmpty(){	while ( root != last ) {		lastParent = last->back;		delete last;		last = lastParent;	}	root->next = NULL;    left = false;}template <class DataType>inline void PriorityQueue<DataType>::insertNode( const DataType & inf ){	last->next = new PQNode<DataType>();    last->next->back = last;    last = last->next;	last->left = last->right = last->next = NULL;    last->parent = lastParent;    if (left)        lastParent->left = last;    else {        lastParent->right = last;        lastParent = lastParent->next;    }    last->info = inf;	left = !left;}// assumes that the subtree rooted at current is a heap except for current;// turns this subtree into a heaptemplate <class DataType>inline void PriorityQueue<DataType>::heapify( PQNode<DataType> *current ){    DataType temp = current->info;    PQNode<DataType> *leftc = current->left, *rightc = current->right, *largest;	largest = (rightc == NULL)? leftc : ((leftc->info > rightc->info)? leftc : rightc );	while ( (leftc != NULL) && largest->info > temp ) {        current->info = largest->info;        current = largest;		leftc = current->left;		rightc = current->right;		largest = (rightc == NULL)? leftc : ((leftc->info > rightc->info)? leftc : rightc );    }    current->info = temp;}template <class DataType>inline void PriorityQueue<DataType>::deepCopy( const PriorityQueue<DataType> & original ){    last = lastParent = root = &rootHeader;	root->next = NULL;	left = false;	PQNode<DataType> *originalptr = original.root->next;	for ( ; originalptr != NULL; originalptr = originalptr->next )  		insertNode( originalptr->info );}