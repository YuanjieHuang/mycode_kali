// queue.cpp -- function definitions for the linked list implementation of a queuetemplate <class DataType>Queue<DataType>::Queue( ){	front = back = &header;}template <class DataType>Queue<DataType>::Queue( const Queue<DataType> & apqueue ){	deepCopy( apqueue );}template <class DataType>Queue<DataType>::~Queue( ){	makeEmpty( );}template <class DataType>Queue<DataType> & Queue<DataType>::operator =( const Queue<DataType> & rqueue ){	if ( this == &rqueue )		return *this;	makeEmpty( );	deepCopy( rqueue );	return *this;}template <class DataType>void Queue<DataType>::enqueue( const DataType & element ){	Node<DataType> *ptr = new Node<DataType>;	ptr->info = element;	back->next = ptr;	back = ptr;}// dequeues element and returns it in deqElement// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::dequeue( DataType & deqElement ){	if ( front == back ) 		return false;	Node<DataType> *ptr = front->next;	deqElement = ptr->info;	front->next = ptr->next;	if ( back == ptr )		back = front;	delete ptr;		return true;}// returns element at the front of the queue into frontElement without removing it// returns false if called on an empty queue; otherwise returns truetemplate <class DataType>bool Queue<DataType>::peek( DataType & frontElement ){	if ( front == back )		return false;	frontElement = front->next->info;	return true;}template <class DataType>bool Queue<DataType>::isEmpty( ) const{   	 return front == back;}template <class DataType>void Queue<DataType>::makeEmpty( ){   	DataType temp;	while ( dequeue( temp ) );}template <class DataType>inline void Queue<DataType>::deepCopy( const Queue<DataType> & original ){	Node<DataType> *copyptr = front = &header; 	Node<DataType> *originalptr = original.front;	while ( originalptr != original.back ) {		originalptr = originalptr->next;		copyptr->next = new Node<DataType>;		copyptr = copyptr->next;		copyptr->info = originalptr->info;	}	back = copyptr;}