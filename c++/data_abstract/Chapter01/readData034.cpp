const int LOW_END=10;   // low end of incomesconst int HIGH_END=100; // high end of incomesconst int TABLE_SIZE = HIGH_END - LOW_END + 1;typedef int TableType[TABLE_SIZE];int index(int group)// Returns the array index that corresponds to group number.{   return group - LOW_END;} // end indexbool readData(TableType incomeData)// ---------------------------------------------------------// Reads and organizes income statistics.// Precondition: The calling program gives directions and// prompts the user. Each input line contains exactly two// integers in the form G N, where N is the number of// people with an income in the G-thousand-dollar group and// LOW_END <= G <= HIGH_END. An input line with values of// zero for both G and N terminates the input.// Postcondition: incomeData[G-LOW_END] = total number of// people with an income in the G-thousand-dollar group.// The values read are displayed. If either G or N is// erroneous (G and N are not both 0, and either G < LOW_END,// G > HIGH_END, or N < 0), the function ignores the data// line, sets the return value to false, and continues.// In this case, the calling program should take action. The// return value is true if the data is error free.// ---------------------------------------------------------{   int group, number;  // input values   bool dataCorrect = true;  // no data error found as yet   for (group = LOW_END; group <= HIGH_END; ++group)      incomeData[index(group)] = 0;   for (cin >> group >> number;        (group != 0) || (number != 0);        cin >> group >> number)   {  // Invariant: group and number are not both 0      cout << "Input line specifies that income group "           << group << "\ncontains " << number           << " people.\n";      if ((group >= LOW_END) && (group <= HIGH_END) &&          (number >= 0))         // input data is valid -- add it to tally         incomeData[index(group)] += number;      else         // error in input data: set error flag and         // ignore input line         dataCorrect = false;   }  // end for   return dataCorrect;}  // end readData