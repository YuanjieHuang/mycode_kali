Point
{
public:
Point( float xval ); virtual ~Point();
float x() const;
static int PointCount();
protected:  
    virtual ostream&  print( ostream &os ) const;
    float _x;  

    static int _point_count;  
};
``` ### 简单对象模型 - 简单对象模型的**概念**：
- 一个C++对象存储了所有指向成员的指针，而成员本身不存储在对象中。
- 也就是说不论数据成员还是成员函数，也不论这个是普通成员函数还是虚函数，它们都存储在对象本身之外，同时对象保存指向它们的指针。
 --- - 简单对象模型对于编译器来说虽然极尽简单,但同时付出的代价是**空间和执行期的效率**.
- 对于每一个成员都要额外搭上一个指针大小的空间
- 对于每成员的操作都增加了一个间接层。 - 因此C++并没有采用这样一种对象模型，但是被用到了C++中 **“指向成员的指针”** 的概念当中。 
![简单对象模型](https://img-blog.csdnimg.cn/20191012211235385.png#pic_center =500x400) ### 表格驱动对象模型 - 表格驱动模型则更绝，
- 它将对象中所有的成员都抽离出来在外建表，
- 而对象本身只存储指向这个表的指针。 - 下图可以看到，
- 它将所有的数据成员抽离出来建成一张 **数据成员表**，
- 将所有的函数抽取出来建成一张 **函数成员表**，
- 而对象本身只保持一个 **指向数据成员表的指针**。
![表格驱动对象模型](https://img-blog.csdnimg.cn/2019101221200329.png#pic_center =500x400) - 
==侯大大认为，在对象与成员函数表中间应当加一个虚箭头，他认为这是Lippman的疏漏之处，应当在对象中保存指向函数成员表的指针。
== - 然而我在这儿还是保留原书（而非译本）的截图，因为以我之拙见，不保存指向成员函数表的指针也没有妨碍。
因为形如float Point::x()的成员函数实际上相当于float x(Point*)类型的普通函数，因此保存指向成员函数表的指针当属多此一举。 
- 当然C++也没有采用这一种对象模型，但C++却**以此模型作为支持虚函数的方案。** ### C++对象模型 - C++对象模型的组成:
- 所有的**非静态数据成员**存储在**对象本身中**。
- 所有的**静态数据成员**、**成员函数（包括静态与非静态）**都置于**对象之外**。
- 另用一张**虚函数表（virtual table) 存储所有指向虚函数的指针**，并在**表头附加上一个该类的type_info对象**，在**对象中则保存一个指向虚函数表的指针**。
 - 如下图:
	![C++对象模型](https://img-blog.csdnimg.cn/20191012213609981.png#pic_center =500x400) 
    ## class和struct关键字的差异 - 按照lippman的意思是，struct仅仅是给想学习C++的C程序员攀上高峰少一点折磨。
    但遗憾的是当我开始学C++的时候这个问题给我带来更多的疑惑。
    以我的认识class与struct仅限一个默认的权限（后者为public前者为private）的不同。
    有时我甚至觉得只有一点畸形，他们不应当如此的相像，我甚至认为struct不应该被扩充，仅仅保存它在C中的原意就好了。
    [^1] [^1]:  实际上struct还要复杂一点，它有时表现的会和C struct完全一样，有时则会成为class的胞兄弟。
     --- -  一个有意思的C技巧（但别在C++中使用）
- 在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组。 
- 这是一个很有意思的小技巧，但是**别在C++中使用**。因为C++的内存布局相对复杂。例如被继承，有虚函数… 问题将不可避免的发生。 - 看代码：
```c
struct mumble {  
    /* stuff */  
    char pc[ 1 ];  
};  
// grab a string from file or standard input  
// allocate memory both for struct & string  
struct mumble *pmumb1 = ( struct mumble* )  
    malloc(sizeof(struct mumble)+strlen(string)+1);  
strcpy( &mumble.pc, string );
``` ## 三种编程典范 - 程序模型：数据和函数分开。 - 抽象数据类型模型：数据和函数一起封装以来提供。 
- 面向对象模型：可通过一个抽象的base class封装起来，用以提供共同接口，需要付出的就是额外的间接性。
